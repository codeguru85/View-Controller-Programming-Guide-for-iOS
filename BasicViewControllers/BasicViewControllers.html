<!DOCTYPE html>
<html lang="en">
<head>
    <title>View Controller Programming Guide for iOS: Custom View Controllers</title>
    <meta http-equiv="X-UA-Compatible" content="IE=7">
    <meta http-equiv="content-type" content="text/html;charset=utf-8">
    <meta id="book-resource-type" name="book-resource-type" content="Guide">
    <script>String.prototype.cleanUpURL=function(){var c,b="",a=this;if(this.match("#")){b="#"+this.split("#")[1];a=this.split("#")[0]}a=a.replace(/\/\.\/|([^:])\/\//g,"$1/");if(a==="./"){return""+b}while(a!==c){c=a;a=a.replace(/[\/][^\/]+\/+\.\.\//,"/")}a=a.replace(/^.[^\/]+\/+\.\.\//,"");return a+b};(function(){var a="../../../";var c=window.location.pathname;var b=(c.slice(0,c.lastIndexOf("/"))+"/"+a).cleanUpURL();if(top.location.href==window.location.href){if("createTouch" in document){if(document.getElementById("book-resource-type").content!=="Standalone"){switch(navigator.platform){case"iPad":window.location.replace(a+"ipad/#"+c.replace(b,"")+window.location.hash);break;case"iPhone":break}}}else{window.location.replace(a+(window.location.protocol=="file:"?"index.html":"")+"#"+c.replace(b,"")+window.location.hash)}}})();</script>
    <meta scheme="apple_ref" id="identifier" name="identifier" content="//apple_ref/doc/uid/TP40007457">
    <meta id="date" name="date" content="2010-11-12">
    <meta id="description" name="description" content="Explains how to use view controllers to implement radio, navigation, and modal interfaces.">
    <meta id="book-title" name="book-title" content="View Controller Programming Guide for iOS">
    <meta id="book-root" name="book-root" content="../">
    <meta id="book-json" name="book-json" content="../book.json">
    <meta id="book-assignments" name="book-assignments" content="{Type/Guide}, {Framework/Cocoa Touch Layer/UIKit}, {Topic/User Experience/Windows & Views}">
    <meta name="pdf" contents="../ViewControllerPGforiPhoneOS.pdf" /><link id="book-pdf" media="print" rel="alternate" type="application/pdf" href="../ViewControllerPGforiPhoneOS.pdf" />
    
    <meta id="generator" name="generator" content="Gutenberg 26027">
    <meta name='numbat' content='aa879094b666337fdcde744b62fbff30'>
    <meta id="copyright" name="copyright" content="Copyright 2010 Apple Inc. All Rights Reserved.">
    <meta name = "viewport" content = "width = device-width" >
    <meta id="xcode-display" name="xcode-display" content="render">
    <meta id="IndexTitle" name="IndexTitle" content="Custom View Controllers">
    <meta id="resources-uri" name="resources-uri" content="../../../Resources/541">
    <link id="book-index-page" rel="Start" title="View Controller Programming Guide for iOS" type="text/html" href="../index.html">
    <link id="next-page" rel="Next" type="text/html" href="../NavigationControllers/NavigationControllers.html">
    <link id="previous-page" rel="Prev" type="text/html" href="../AboutViewControllers/AboutViewControllers.html">
    <link rel="stylesheet" type="text/css" href="../../../Resources/541/CSS/ac_media.css" charset="utf-8">
    <link rel="stylesheet" type="text/css" href="../../../Resources/541/CSS/devpubs.css" charset="utf-8">
    <link rel="stylesheet" type="text/css" href="../../../Resources/541/CSS/docs.css" charset="utf-8">
    <!--[if IE]><link rel="stylesheet" type="text/css" href="../../../Resources/541/CSS/ie.css"><![endif]-->
    
</head>    
<body><a name="//apple_ref/doc/uid/TP40007457-CH101" title="Custom View Controllers"></a>
    <article id="contents" tabindex="0" role="main">
        <!-- CONTENTS -->
        <div id="pageNavigationLinks_top" class="pageNavigationLinks">
            <a class='nextLink' rel='next' href='../NavigationControllers/NavigationControllers.html'>Next</a><a class='previousLink' rel='prev' href='../AboutViewControllers/AboutViewControllers.html'>Previous</a>
        </div>
        <a id="top" name="top"></a>
        <a id="INDEX" href="../index.html" style="display:none;"></a>
        
        <a name="//apple_ref/doc/uid/TP40007457-CH101-SW1" title="Custom View Controllers"></a><br /><h1 id="pageTitle">Custom View Controllers</h1><p>Custom view controllers are what you use to present the content of your application. The job of any view controller is to manage the presentation of some content and coordinate the update and the synchronization of that content with the application’s underlying data objects. In the case of a custom view controller, this involves creating a view to present the content and implementing the infrastructure needed to synchronize the contents of that view with your application’s data structures. </p><p>The <code><a href="../../../documentation/UIKit/Reference/UIViewController_Class/Reference/Reference.html#//apple_ref/occ/cl/UIViewController" target="_self">UIViewController</a></code> class provides the basic behavior required for all view controllers—custom or otherwise. This chapter explains the fundamental behaviors provided by this class and also shows you how to modify those behaviors to suit the needs of your application. Understanding these behaviors and how you can modify them is essential to implementing your application’s custom view controllers; it is also useful when interacting with view controllers of any type.  </p><section><a name="//apple_ref/doc/uid/TP40007457-CH101-SW35" title="Anatomy of a Custom View Controller"></a><h2 class="jump">Anatomy of a Custom View Controller</h2><p>The <code><a href="../../../documentation/UIKit/Reference/UIViewController_Class/Reference/Reference.html#//apple_ref/occ/cl/UIViewController" target="_self">UIViewController</a></code> class provides the fundamental infrastructure for implementing all custom view controllers. Although you can configure an instance of the <code>UIViewController</code> class to display some views, you need to <span class="pediaLink" data-header="Class definition" data-contents="A class definition is the specification of a class of objects through the use of certain files and syntax. "><a href="../../../documentation/General/Conceptual/DevPedia-CocoaCore/ClassDefinition.html#//apple_ref/doc/uid/TP40008195-CH6" target="_self">define a custom subclass</a></span> if you want to do anything interesting. In your subclass, you use custom methods to populate views with data and respond to taps in buttons and other controls. However, when you want to make adjustments to the default behavior of the view controller, you need to <span class="pediaLink" data-header="Method overriding" data-contents="Method overriding is a language feature in which a class can provide an implementation of a method that is already provided by one of its parent classes. "><a href="../../../documentation/General/Conceptual/DevPedia-CocoaCore/MethodOverriding.html#//apple_ref/doc/uid/TP40008195-CH57" target="_self">override methods</a></span> of the <code>UIViewController</code> class. You may also need to interact with other UIKit classes to implement the behavior you want. </p><p><span class="content_text">Figure 2-1</span> shows some of the key objects associated directly with a custom view controller. These are the objects that are essentially owned and managed by the view controller itself. The view (accessible via the <code><a href="../../../documentation/UIKit/Reference/UIViewController_Class/Reference/Reference.html#//apple_ref/occ/instp/UIViewController/view" target="_self">view</a></code> property) is the only object that must be provided, although most view controllers also have some custom objects containing the data they need to display. Other objects are used only as needed to support features such as navigation and tab bar interfaces, and even so, most provide default behavior that is often sufficient.</p><figure><a name="//apple_ref/doc/uid/TP40007457-CH101-SW50" title="Figure 2-1Anatomy of a custom view controller"></a><figcaption><strong>Figure 2-1&nbsp;&nbsp;</strong>Anatomy of a custom view controller</figcaption><img src="../Art/vc_anatomy.jpg" alt="" width="503" height="311"></figure><p>Although view controllers rarely act alone, custom view controllers should always be designed to be independent objects. In other words, a view controller should encapsulate all of the behavior associated with managing the views in its view hierarchy. Your view controller should contain the data it needs (or at least a reference to that data that it controls), the views needed to display that data, the logic to assimilate changes in the system (such as orientation changes), and the code needed to validate or process user interactions. Any custom objects needed to manage portions of the view hierarchy or data model should be created and managed wholly by the view controller.  </p></section><section><a name="//apple_ref/doc/uid/TP40007457-CH101-SW31" title="Implementation Checklist for Custom View Controllers"></a><h2 class="jump">Implementation Checklist for Custom View Controllers</h2><p>When you want to implement a custom view controller for your application, you use Xcode to set up your source files. Most iOS project templates include at least one view controller class and you can create new view controllers in Xcode as needed. </p><p>For any custom view controllers you create, there are several tasks that you should always handle:  </p><ul class="ul"><li class="li"><p>You must configure the view to be loaded by your view controller; see <span class="content_text"><a href="#//apple_ref/doc/uid/TP40007457-CH101-SW2">“Creating the View for Your View Controller.”</a></span></p></li><li class="li"><p>You must decide which orientations your view controller supports; see <span class="content_text"><a href="#//apple_ref/doc/uid/TP40007457-CH101-SW3">“Managing a View Controller’s Interface Orientation.”</a></span> </p></li><li class="li"><p>You must clean up the memory that is managed by your view controller; see <span class="content_text"><a href="#//apple_ref/doc/uid/TP40007457-CH101-SW4">“Managing Memory Efficiently.”</a></span></p></li></ul><p>As you configure your view controller’s view, you will likely discover that you need to define action methods or outlets to use with those views. For example, if your view hierarchy contains a table, you probably want to store a pointer to that table in an outlet so that you can access it later. Similarly, if your view hierarchy contains buttons or other controls, you may want those controls to call an associated action method in response to user interactions. As you iterate through the <span class="pediaLink" data-header="Class definition" data-contents="A class definition is the specification of a class of objects through the use of certain files and syntax. "><a href="../../../documentation/General/Conceptual/DevPedia-CocoaCore/ClassDefinition.html#//apple_ref/doc/uid/TP40008195-CH6" target="_self">definition of your view controller class</a></span>, you may therefore find that you need to add the following items to your view controller class:</p><ul class="ul"><li class="li"><p><span class="pediaLink" data-header="Class definition" data-contents="A class definition is the specification of a class of objects through the use of certain files and syntax. "><a href="../../../documentation/General/Conceptual/DevPedia-CocoaCore/ClassDefinition.html#//apple_ref/doc/uid/TP40008195-CH6" target="_self">Member variables</a></span> pointing to the objects containing the data to be displayed by the corresponding views</p></li><li class="li"><p>Member variables (or outlets) pointing to key view objects with which your view controller must interact</p></li><li class="li"><p>Action methods that perform tasks associated with buttons and other controls in the view hierarchy</p></li><li class="li"><p>Any additional methods needed to implement your view controller’s custom behavior </p></li></ul><div class="importantbox clear"><aside><a name="//apple_ref/doc/uid/TP40007457-CH101-DontLinkElementID_2" title="Important:"></a><p><strong>Important:</strong>&nbsp;When adding outlets or other member variables to your custom view controllers, it is highly recommended that you include <span class="pediaLink" data-header="Declared property" data-contents="A declared property provides a syntactical shorthand for declaring a class’s accessor methods and, optionally, implementing them. "><a href="../../../documentation/General/Conceptual/DevPedia-CocoaCore/DeclaredProperty.html#//apple_ref/doc/uid/TP40008195-CH13" target="_self">declared properties</a></span> for each variable you intend to access. Declared properties provide a convenient syntax for accessing member variables and also eliminate the need for you to write much of the glue code required for managing those variables. Especially when referring to other objects, properties can provide tremendous convenience by automatically retaining and releasing objects as needed. </p><p></p></aside></div><p>The preceding items are the ones that you are the most likely to include in every custom view controller class you create. However, there are other methods you might add to your view controller to implement specific behaviors. Many of these methods take advantage of hooks in the view controller infrastructure to implement common tasks.</p><ul class="ul"><li class="li"><p>You can adjust your view hierarchy or application state in response to the view controller’s view appearing or disappearing from the screen; see <span class="content_text"><a href="#//apple_ref/doc/uid/TP40007457-CH101-SW39">“Responding to Display-Related Notifications.”</a></span> </p></li><li class="li"><p>You can configure objects used by navigation and tab bar controllers, including:</p><ul class="nested"><li class="nested li"><p>The navigation item (if the controller is used in conjunction with a navigation controller interface); see <span class="content_text"><a href="../NavigationControllers/NavigationControllers.html#//apple_ref/doc/uid/TP40007457-CH103-SW3">“Customizing the Navigation Bar Appearance.”</a></span> </p></li><li class="nested li"><p>The toolbar items (if an associated navigation controller displays a toolbar); see <span class="content_text"><a href="../NavigationControllers/NavigationControllers.html#//apple_ref/doc/uid/TP40007457-CH103-SW26">“Specifying the Toolbar Items.”</a></span> </p></li><li class="nested li"><p>The tab bar item (if the view controller is used in conjunction with a tab bar controller interface); see <span class="content_text"><a href="../TabBarControllers/TabBarControllers.html#//apple_ref/doc/uid/TP40007457-CH102-SW2">“Creating a Tab Bar Interface.”</a></span> </p></li></ul></li><li class="li"><p>You can adjust your view hierarchy when the interface orientation changes; see <span class="content_text"><a href="#//apple_ref/doc/uid/TP40007457-CH101-SW23">“Responding to Orientation Changes.”</a></span></p></li><li class="li"><p>You can implement event handlers to catch any events not handled by the view or its subviews; see <em><a href="../../../documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Introduction/Introduction.html#//apple_ref/doc/uid/TP40009541" target="_self">Event Handling Guide for iOS</a></em>. </p></li><li class="li"><p>You can implement an editable version of your view; see <span class="content_text"><a href="#//apple_ref/doc/uid/TP40007457-CH101-SW30">“Enabling Edit Mode for a View.”</a></span> </p></li></ul></section><section><a name="//apple_ref/doc/uid/TP40007457-CH101-SW19" title="Understanding the View Management Cycle"></a><h2 class="jump">Understanding the View Management Cycle</h2><p>In a view controller object, management of the corresponding view occurs in two distinct cycles: the load and unload cycles. The load cycle occurs whenever some part of your application asks the view controller for a pointer to its view object and that object is not currently in memory. When that happens, the view controller loads the view into memory and stores a pointer to the view for future reference. </p><p>If your application receives a low-memory warning at some point in the future, the view controller may subsequently try to unload the view. During the unload cycle, the view controller attempts to release its view object and return the view controller to its initial viewless state. If it is able to release the view, the view controller remains without a view object until the view is once again requested, at which point the load cycle begins again.</p><p>During the load and unload cycles, the view controller does most of the work of loading and unloading the view. However, if your view controller class stores references to views in the view hierarchy or needs to perform some additional configuration of the views at load time, you can <span class="pediaLink" data-header="Method overriding" data-contents="Method overriding is a language feature in which a class can provide an implementation of a method that is already provided by one of its parent classes. "><a href="../../../documentation/General/Conceptual/DevPedia-CocoaCore/MethodOverriding.html#//apple_ref/doc/uid/TP40008195-CH57" target="_self">override</a></span> specific methods (which are described in the material that follows) to perform any extra tasks.  </p><p>The steps that occur during the load cycle are as follows:</p><ol class="ol"><li class="li"><p>Some part of your application asks for the view in the view controller’s <code><a href="../../../documentation/UIKit/Reference/UIViewController_Class/Reference/Reference.html#//apple_ref/occ/instp/UIViewController/view" target="_self">view</a></code> property. </p></li><li class="li"><p>If the view is not currently in memory, the view controller calls its <code><a href="../../../documentation/UIKit/Reference/UIViewController_Class/Reference/Reference.html#//apple_ref/occ/instm/UIViewController/loadView" target="_self">loadView</a></code> method.</p></li><li class="li"><p>The <code>loadView</code> method does one of the following:</p><ul class="ul"><li class="li"><p>If you override this method, your implementation is responsible for creating all necessary views and assigning a non-<code>nil</code> value to the <code>view</code> property.</p></li><li class="li"><p>If you do not override this method, the default implementation uses the <code><a href="../../../documentation/UIKit/Reference/UIViewController_Class/Reference/Reference.html#//apple_ref/occ/instp/UIViewController/nibName" target="_self">nibName</a></code> and <code><a href="../../../documentation/UIKit/Reference/UIViewController_Class/Reference/Reference.html#//apple_ref/occ/instp/UIViewController/nibBundle" target="_self">nibBundle</a></code> properties of the view controller to try to load the view from the specified <span class="pediaLink" data-header="Nib file" data-contents="A nib file is a special type of resource file that you use to store the user interfaces of iOS and Mac OS X applications. "><a href="../../../documentation/General/Conceptual/DevPedia-CocoaCore/NibFile.html#//apple_ref/doc/uid/TP40008195-CH34" target="_self">nib file</a></span>. If the specified nib file is not found, it looks for a nib file whose name matches the name of the view controller class and loads that file.</p></li><li class="li"><p>If no nib file is available, the method creates an empty <code><a href="../../../documentation/UIKit/Reference/UIView_Class/UIView/UIView.html#//apple_ref/occ/cl/UIView" target="_self">UIView</a></code> object and assigns it to the <code>view</code> property.</p></li></ul></li><li class="li"><p>The view controller calls its <code><a href="../../../documentation/UIKit/Reference/UIViewController_Class/Reference/Reference.html#//apple_ref/occ/instm/UIViewController/viewDidLoad" target="_self">viewDidLoad</a></code> method to perform any additional load-time tasks.</p></li></ol><p><span class="content_text">Figure 2-2</span> shows a visual representation of the load cycle, including several of the methods that are called. Your application can override both the <code>loadView</code> and <code>viewDidLoad</code> methods as needed to facilitate the behavior you want for your view controller. </p><figure><a name="//apple_ref/doc/uid/TP40007457-CH101-SW5" title="Figure 2-2Loading a view into memory"></a><figcaption><strong>Figure 2-2&nbsp;&nbsp;</strong>Loading a view into memory</figcaption><img src="../Art/viewloading_process.jpg" alt="" width="438" height="413"></figure><p>The steps that occur during the unload cycle are as follows:</p><ol class="ol"><li class="li"><p>The application receives a low-memory warning from the system.</p></li><li class="li"><p>Each view controller calls its <code><a href="../../../documentation/UIKit/Reference/UIViewController_Class/Reference/Reference.html#//apple_ref/occ/instm/UIViewController/didReceiveMemoryWarning" target="_self">didReceiveMemoryWarning</a></code> method:</p><ul class="ul"><li class="li"><p>If you override this method, you should use it to release any custom data that your view controller object no longer needs. You should not use it to release your view controller’s view. You must call <code>super</code> at some point in your implementation to perform the default behavior.</p></li><li class="li"><p>The default implementation releases the view only if it determines that it is safe to do so.</p></li></ul></li><li class="li"><p>If the view controller releases its view, it calls its <code><a href="../../../documentation/UIKit/Reference/UIViewController_Class/Reference/Reference.html#//apple_ref/occ/instm/UIViewController/viewDidUnload" target="_self">viewDidUnload</a></code> method. You can override this method to perform any additional cleanup required for your views and view hierarchy.</p></li></ol><p><span class="content_text">Figure 2-3</span> shows a visual representation of the unload cycle for a view controller. </p><figure><a name="//apple_ref/doc/uid/TP40007457-CH101-SW6" title="Figure 2-3Unloading a view from memory"></a><figcaption><strong>Figure 2-3&nbsp;&nbsp;</strong>Unloading a view from memory</figcaption><img src="../Art/viewunloading_process.jpg" alt="" width="338" height="288"></figure><div class="importantbox clear"><aside><a name="//apple_ref/doc/uid/TP40007457-CH101-DontLinkElementID_3" title="Important:"></a><p><strong>Important:</strong>&nbsp;In iOS 3.0 and later, the <code>viewDidUnload</code> method is the preferred place to put any code related to cleaning up your views. You might also override the <code><a href="../../../documentation/UIKit/Reference/UIViewController_Class/Reference/Reference.html#//apple_ref/occ/instm/UIViewController/didReceiveMemoryWarning" target="_self">didReceiveMemoryWarning</a></code> method to release temporary caches or other private data that is no longer needed when the view is released. If you do override <code>didReceiveMemoryWarning</code>, always call <code>super</code> to give the inherited version of the method a chance to release the view. </p><p>In iOS 2.2 and earlier, you must use the <code><a href="../../../documentation/UIKit/Reference/UIViewController_Class/Reference/Reference.html#//apple_ref/occ/instm/UIViewController/didReceiveMemoryWarning" target="_self">didReceiveMemoryWarning</a></code> method to perform your view-related cleanup and to release any unneeded private data structures. The <code>viewDidUnload</code> method is available only in iOS 3.0 and later.  </p><p>For more information about managing memory during low-memory conditions, see <span class="content_text"><a href="#//apple_ref/doc/uid/TP40007457-CH101-SW4">“Managing Memory Efficiently.”</a></span> </p><p></p></aside></div></section><section><a name="//apple_ref/doc/uid/TP40007457-CH101-SW48" title="Defining a Custom View Controller Class"></a><h2 class="jump">Defining a Custom View Controller Class</h2><p>A custom view controller is a subclass of <code><a href="../../../documentation/UIKit/Reference/UIViewController_Class/Reference/Reference.html#//apple_ref/occ/cl/UIViewController" target="_self">UIViewController</a></code> that you use to present your application’s content. Many of the Xcode project templates come with a custom view controller class that you can modify for your needs. If you need to create additional custom view controllers, do the following: </p><ol class="ol"><li class="li"><p>Choose File > New File to add a new source file to your project.</p><p>You want to create a new <code>UIViewController</code> subclass. There is a template for this type of class in the Cocoa Touch Classes section of the New File dialog.</p></li><li class="li"><p>Give your new view controller file an appropriate name and add it to your project. </p></li><li class="li"><p>Save your source files.</p></li></ol><p>Once you have your view controller source files, you can implement the behaviors needed to present your content. The following sections describe the key tasks you can perform using a custom view controller. For additional information about creating a view controller, see <em><a href="../../../documentation/UIKit/Reference/UIViewController_Class/Reference/Reference.html#//apple_ref/doc/uid/TP40006926" target="_self">UIViewController Class Reference</a></em>. </p><section><a name="//apple_ref/doc/uid/TP40007457-CH101-SW2" title="Creating the View for Your View Controller"></a><h3 class="jump">Creating the View for Your View Controller</h3><p>The main job of a view controller is to load and unload its view as needed. Most view controllers load their views from an associated <span class="pediaLink" data-header="Nib file" data-contents="A nib file is a special type of resource file that you use to store the user interfaces of iOS and Mac OS X applications. "><a href="../../../documentation/General/Conceptual/DevPedia-CocoaCore/NibFile.html#//apple_ref/doc/uid/TP40008195-CH34" target="_self">nib file</a></span>. The advantage of using nib files is that they allow you to lay out and configure your views graphically, making it easier and faster to adjust your layout. However, you can also create the view programmatically if you prefer.</p><section><a name="//apple_ref/doc/uid/TP40007457-CH101-SW32" title="Creating the View in Interface Builder"></a><h4 class="jump">Creating the View in Interface Builder</h4><p>Interface Builder provides an intuitive way to create and configure the views for your view controllers. As its name suggests, Interface Builder is a tool for building your application’s interface graphically, as opposed to programmatically. Using this application, you assemble views and controls by manipulating them directly, dragging them into the workspace, positioning them, sizing them, and modifying their attributes using an inspector window. The results are then saved in a nib file, which stores the collection of objects you assembled along with information about all the customizations you made.</p><p>There are two ways to configure a nib file for use with a view controller:</p><ul class="ul"><li class="li"><p>Create a <strong>detached nib file</strong> by storing the view in a nib file by itself.</p></li><li class="li"><p>Create an <strong>integrated nib file</strong> by storing both the view and view controller in the same nib file.</p></li></ul><p>Of the two techniques, using a detached nib file is by far the preferred way to go. Detached nib files offer a more robust solution, especially in the realm of memory management. During a low-memory condition, the contents of a detached nib file can be purged from memory as needed without affecting the state of the owning view controller object. The same is not true in the case of an integrated nib file, the contents of which must stay in memory until all nib-file objects are no longer needed.</p><section><a name="//apple_ref/doc/uid/TP40007457-CH101-SW33" title="Storing the View in a Detached Nib File"></a><h5 class="jump">Storing the View in a Detached Nib File</h5><p>The process for creating a detached <span class="pediaLink" data-header="Nib file" data-contents="A nib file is a special type of resource file that you use to store the user interfaces of iOS and Mac OS X applications. "><a href="../../../documentation/General/Conceptual/DevPedia-CocoaCore/NibFile.html#//apple_ref/doc/uid/TP40008195-CH34" target="_self">nib file</a></span> involves two separate implementation steps:</p><ul class="ul"><li class="li"><p>You must configure a nib file with the view. </p></li><li class="li"><p>You must associate that nib file with your view controller object.</p></li></ul><p>The configuration of the nib file itself is relatively straightforward. If you are creating the nib file from scratch, you should use the Cocoa Touch View template in Interface Builder as your starting point. The nib file created by this template contains the File’s Owner placeholder and a single custom view object. Add this new nib file to your Xcode project and then configure its contents as follows: </p><ol class="ol"><li class="li"><p>Set the class name of the File’s Owner placeholder to your view controller class.</p><p>You should have already created the class in your Xcode project. For new nib files, the class of File’s Owner is set to <code>NSObject</code> by default. (If you are editing a nib file that was provided for you by one of the Xcode project templates, the class may already be set to the correct view controller class name.)</p></li><li class="li"><p>Make sure the <code>view</code> outlet of the File’s Owner placeholder is connected to the top-level View object in the nib file. </p><p>This <code>view</code> outlet is defined by the <code>UIViewController</code> class and inherited by all view controller objects. If you do not see this outlet in the File’s Owner placeholder, check to see whether you added the nib file to your Xcode project. Associating the nib file with an Xcode project lets Interface Builder retrieve information about the classes in that project automatically. This is necessary to determine the available outlets and actions of those classes.</p><p>If you forget to connect this outlet, the <code><a href="../../../documentation/UIKit/Reference/UIViewController_Class/Reference/Reference.html#//apple_ref/occ/instp/UIViewController/view" target="_self">view</a></code> property of your view controller class is set to <code>nil</code> when the nib file is loaded, which prevents your view from being presented on the screen. </p></li><li class="li"><p>Configure the view itself and add any subviews you need to display your application’s content.</p></li><li class="li"><p>Save the nib file.</p></li></ol><p>After creating the nib file and adding it to your Xcode project, you need to <span class="pediaLink" data-header="Initialization" data-contents="Initialization is the stage of object creation that makes a newly allocated object usable by setting its state to reasonable initial values. "><a href="../../../documentation/General/Conceptual/DevPedia-CocoaCore/Initialization.html#//apple_ref/doc/uid/TP40008195-CH21" target="_self">initialize</a></span> your view controller object with the name of that nib file. How you initialize your view controller object depends on how you create it. If you are creating your view controller programmatically, pass the name of the nib file to the <code><a href="../../../documentation/UIKit/Reference/UIViewController_Class/Reference/Reference.html#//apple_ref/occ/instm/UIViewController/initWithNibName:bundle:" target="_self">initWithNibName:bundle:</a></code> method when you initialize your view controller object. If you are loading your view controller object from a separate nib file (one other than the one containing the view), use Interface Builder to set the value NIB Name attribute of the view controller object to the name of your view’s nib file. </p><p><span class="content_text">Listing 2-1</span> shows an example of how you would create and initialize a view controller programmatically. In this case, the custom class uses a nib file with the same name to store its view. After initializing the view controller, you can use the view controller as you see fit, including presenting it to the user, as is done in the example. </p><a name="//apple_ref/doc/uid/TP40007457-CH101-SW12" title="Listing 2-1Creating a view controller object programmatically"></a><p class="codesample clear"><strong>Listing 2-1&nbsp;&nbsp;</strong>Creating a view controller object programmatically</p><div class="codesample clear"><table><tr><td scope="row"><pre>- (void)displayModalView<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>   MyViewController* vc = [[[MyViewController alloc] initWithNibName:@"MyViewController"<span></span></pre></td></tr><tr><td scope="row"><pre>                               bundle:nil] autorelease];<span></span></pre></td></tr><tr><td scope="row"><pre>   [self presentModalViewController:vc animated:YES];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>For a detached nib file, the actual loading of the nib file occurs automatically when the <code>view</code> property of the view controller object is accessed and the view is not currently in memory. The default <code><a href="../../../documentation/UIKit/Reference/UIViewController_Class/Reference/Reference.html#//apple_ref/occ/instm/UIViewController/loadView" target="_self">loadView</a></code> method uses the <code><a href="../../../documentation/UIKit/Reference/UIViewController_Class/Reference/Reference.html#//apple_ref/occ/instp/UIViewController/nibName" target="_self">nibName</a></code> and <code><a href="../../../documentation/UIKit/Reference/UIViewController_Class/Reference/Reference.html#//apple_ref/occ/instp/UIViewController/nibBundle" target="_self">nibBundle</a></code> properties to locate the desired nib file and load its contents into memory. </p><p><span class="content_text">Figure 2-4</span> shows the runtime configuration of a view controller and its detached nib file prior to loading. The <code>nibName</code> property of the view controller stores a string with the name of the nib file. This string is used to locate the nib file in the application’s bundle. Inside the nib file, the File’s Owner placeholder stands in for the view controller object and is used to connect the view controller’s outlets and actions to objects in the nib file. After the nib file is loaded, the <code>view</code> property of the view controller object points to the view from the nib file. </p><figure><a name="//apple_ref/doc/uid/TP40007457-CH101-SW49" title="Figure 2-4Loading a view from a detached nib file"></a><figcaption><strong>Figure 2-4&nbsp;&nbsp;</strong>Loading a view from a detached nib file</figcaption><img src="../Art/ib_nibconfig1.jpg" alt="" width="386" height="356"></figure><p>For more information about how to create a nib file or configure its contents, see <em><a href="../../../documentation/DeveloperTools/Conceptual/IB_UserGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40005344" target="_self">Interface Builder User Guide</a></em>. For information about configuring custom outlets and actions for your view controller, see <span class="content_text"><a href="#//apple_ref/doc/uid/TP40007457-CH101-SW11">“Configuring Actions and Outlets for Your View Controller.”</a></span></p></section><section><a name="//apple_ref/doc/uid/TP40007457-CH101-SW34" title="Storing the View and View Controller in the Same Nib File"></a><h5 class="jump">Storing the View and View Controller in the Same Nib File</h5><p>If your application has only one screen, you can include both the views for that screen and the view controller that manages them in the same <span class="pediaLink" data-header="Nib file" data-contents="A nib file is a special type of resource file that you use to store the user interfaces of iOS and Mac OS X applications. "><a href="../../../documentation/General/Conceptual/DevPedia-CocoaCore/NibFile.html#//apple_ref/doc/uid/TP40008195-CH34" target="_self">nib file</a></span>. Storing views and custom view controller objects in the same nib file is generally not recommended because it often prevents the system from unloading the views in low-memory situations. However, if the view itself is never going to be unloaded, including it in the same nib file as its view controller object might make the most sense.</p><p><span class="content_text">Figure 2-5</span> shows the main nib file of an application that presents a single screen in its window. In this case, the nib file includes both a custom view controller object (<code>MyViewController</code>) and the view managed by that view controller. Notice that the view object is nested inside the view controller object in the document window. Nesting the view in this manner is preferred because it allows Interface Builder to keep both the view and its view controller in sync. </p><figure><a name="//apple_ref/doc/uid/TP40007457-CH101-SW14" title="Figure 2-5Embedding a view controller in a nib file"></a><figcaption><strong>Figure 2-5&nbsp;&nbsp;</strong>Embedding a view controller in a nib file</figcaption><img src="../Art/viewcontroller_nib2.jpg" alt="" width="456" height="360"></figure><p>To configure the nib file shown in <span class="content_text">Figure 2-5</span>, you would do the following:</p><ol class="ol"><li class="li"><p>Drag a View Controller (<code>UIViewController</code>) object from the library to your Interface Builder document window.</p></li><li class="li"><p>Add a generic View object to the view controller in one of the following ways: </p><ul class="ul"><li class="li"><p>Drag the view to the View Controller’s workspace window. </p></li><li class="li"><p>Drag the view to the view controller object in the Interface Builder document window. </p><div class="importantbox clear"><aside><a name="//apple_ref/doc/uid/TP40007457-CH101-DontLinkElementID_4" title="Important:"></a><p><strong>Important:</strong>&nbsp;Always drag the view to the view controller object in order to nest it inside the view controller (as shown in <span class="content_text"><a href="#//apple_ref/doc/uid/TP40007457-CH101-SW14">Figure 2-5</a></span>). In Interface Builder, view controller objects take into account the presence of the status bar, translucency effects, and other factors that can affect affect the position of the view inside its parent window. If you do not embed the view inside the view controller object, these factors are not taken into account and your view may be positioned incorrectly.</p><p></p></aside></div></li></ul></li><li class="li"><p>Drag an Image View from the library to the generic view.</p></li><li class="li"><p>Drag a Table View from the library to the generic view.</p></li><li class="li"><p>Save the nib file.</p></li></ol><div class="notebox"><aside><a name="//apple_ref/doc/uid/TP40007457-CH101-SW51" title="Note"></a><p><strong>Note:</strong>&nbsp;Although the preceding example used a generic <code><a href="../../../documentation/UIKit/Reference/UIView_Class/UIView/UIView.html#//apple_ref/occ/cl/UIView" target="_self">UIView</a></code> object as the view controller’s root view, you can add any single view you want, including custom subclasses of <code>UIView</code> that you define. To use one of your own subclasses, add a generic <code>UIView</code> object and change its class name using the Identity Inspector.</p><p></p></aside></div><p>Whenever you add objects to the top-level of your nib file, you should always connect those objects to outlets somewhere else in the nib file. In the case of the preceding nib file, this would mean defining an outlet in your application delegate object and connecting that outlet to the custom view controller object. Without the outlet, your code would have no way to access the view controller at runtime. In addition, because top-level objects are retained and then autoreleased, if you did not retain the object, it might possibly be released before you had a chance to use it.  </p><p>Because they are stored in the same nib file, both the view controller and its view are ready to be used after the nib file has been loaded into memory. In the case of the main nib file, you would typically include some code in your application delegate’s <code><a href="../../../documentation/UIKit/Reference/UIApplicationDelegate_Protocol/Reference/Reference.html#//apple_ref/occ/intfm/UIApplicationDelegate/applicationDidFinishLaunching:" target="_self">applicationDidFinishLaunching:</a></code> method to add the view controller’s view to your window, as described in <span class="content_text"><a href="#//apple_ref/doc/uid/TP40007457-CH101-SW25">“Presenting a View Controller’s View.”</a></span> </p></section><section><a name="//apple_ref/doc/uid/TP40007457-CH101-SW52" title="Configuring the View Display Attributes in Interface Builder"></a><h5 class="jump">Configuring the View Display Attributes in Interface Builder</h5><p>To help you lay out the contents of your view properly, Interface Builder provides controls that let you specify whether the view has a navigation bar, a toolbar, or other objects that might affect the position of your custom content. <span class="content_text">Table 2-1</span> lists the items that you can configure and the impact they have on your view controller or views. For a detached nib file, you configure these items by modifying attributes of the view object. For integrated nib files, you configure these items by modifying attributes of the view controller object.</p><a name="//apple_ref/doc/uid/TP40007457-CH101-SW15" title="Table 2-1Configurable items for a view controller"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 2-1&nbsp;&nbsp;</strong>Configurable items for a view controller</caption><tr><th scope="col" class="TableHeading_TableRow_TableCell"><p>Configurable items</p></th><th scope="col" class="TableHeading_TableRow_TableCell"><p>Description</p></th></tr><tr><td  scope="row"><p>Status bar</p></td><td ><p>You can specify whether the status bar is visible and what type of status bar your application displays by changing the Status Bar attribute in the Attributes inspector. This attribute is for design purposes only and is provided so that you can get a complete picture of how your views and controls will look when they are displayed with the status bar. </p><p>The value of Status Bar attribute is not saved with your nib file. The actual style of the status bar (and whether it is present) must be set programmatically by your application at runtime.  </p></td></tr><tr><td  scope="row"><p>Navigation bar</p></td><td ><p>You can specify whether your view has a navigation bar by changing the value of the Top Bar attribute in the Attributes inspector. This attribute is for design purposes only and is provided so that you can get a complete picture of how your views and controls will look when displayed with a navigation bar. Interface Builder lets you configure several different navigation bar styles, including navigation bars with extra space for prompt text. </p><p>The value of the Top Bar attribute is not saved with your nib file. The actual style of the navigation bar (and whether it is present) is controlled by the owning navigation controller. For information on how to configure the navigation bar, see <span class="content_text"><a href="../NavigationControllers/NavigationControllers.html#//apple_ref/doc/uid/TP40007457-CH103-SW3">“Customizing the Navigation Bar Appearance.”</a></span> </p></td></tr><tr><td  scope="row"><p>Tab bar</p></td><td ><p>You can specify whether your view has a tab bar by changing the value of the Bottom Bar attribute in the Attributes inspector. This attribute is primarily for design purposes and is provided so that you can get a complete picture of how your views and controls will look in the presence of a tab bar. </p><p>If you are actually configuring a tab bar controller, tab bar items may be added to the individual view controllers associated with the tabs of the tab bar interface. For more information about configuring tab bar controllers and tab bar items, see <span class="content_text"><a href="../TabBarControllers/TabBarControllers.html#//apple_ref/doc/uid/TP40007457-CH102-SW2">“Creating a Tab Bar Interface.”</a></span>  </p></td></tr><tr><td  scope="row"><p>Toolbar items</p></td><td ><p>To specify that your view uses the toolbar provided by a navigation controller, set the Bottom Bar attribute in the Attributes inspector to Toolbar. This attribute is primarily for design purposes when creating a navigation interface. You can use it to see how your views and controls will look in the presence of a tab bar.</p><p>If you are actually configuring a navigation controller, you can also include the bar button items for your view controller’s toolbar in your nib file. For more information on configuring toolbars in a navigation interface, see <span class="content_text"><a href="../NavigationControllers/NavigationControllers.html#//apple_ref/doc/uid/TP40007457-CH103-SW4">“Displaying a Navigation Toolbar.”</a></span>  </p></td></tr><tr><td  scope="row"><p>Title</p></td><td ><p>In an integrated nib file, you can specify a title for your view controller by assigning an appropriate value to the Title attribute. Navigation and tab bar controllers use the value of this attribute as a default value to use when displaying your view controller.  </p></td></tr><tr><td  scope="row"><p>Nib name</p></td><td ><p>For view controllers embedded in a nib file, you use the NIB Name attribute to specify the name of the detached nib file containing the view controller’s view. For information on how to configure a detached nib file, see <span class="content_text"><a href="#//apple_ref/doc/uid/TP40007457-CH101-SW33">“Storing the View in a Detached Nib File.”</a></span> </p><p>When the view controller is loaded into memory at runtime, the value for this attribute is used to set the value of the view controller’s  <code><a href="../../../documentation/UIKit/Reference/UIViewController_Class/Reference/Reference.html#//apple_ref/occ/instp/UIViewController/nibName" target="_self">nibName</a></code> property.</p></td></tr></table></div><p>The configuration of navigation and tab bar controllers in nib files is a little more involved and is discussed in the following places: </p><ul class="ul"><li class="li"><p>For information about how to configure a navigation controller object by itself, see <span class="content_text"><a href="../NavigationControllers/NavigationControllers.html#//apple_ref/doc/uid/TP40007457-CH103-SW27">“Creating a Navigation Interface.”</a></span></p></li><li class="li"><p>For information about how to configure a tab bar controller by itself, see <span class="content_text"><a href="../TabBarControllers/TabBarControllers.html#//apple_ref/doc/uid/TP40007457-CH102-SW2">“Creating a Tab Bar Interface.”</a></span></p></li><li class="li"><p>For information about how to configure combinations of navigation and tab bar controllers, see <span class="content_text"><a href="../CombiningViewControllers/CombiningViewControllers.html#//apple_ref/doc/uid/TP40007457-CH104-SW2">“Adding a Navigation Controller to a Tab Bar Interface.”</a></span></p></li></ul></section><section><a name="//apple_ref/doc/uid/TP40007457-CH101-SW11" title="Configuring Actions and Outlets for Your View Controller"></a><h5 class="jump">Configuring Actions and Outlets for Your View Controller</h5><p>Regardless of whether you use a detached or integrated <span class="pediaLink" data-header="Nib file" data-contents="A nib file is a special type of resource file that you use to store the user interfaces of iOS and Mac OS X applications. "><a href="../../../documentation/General/Conceptual/DevPedia-CocoaCore/NibFile.html#//apple_ref/doc/uid/TP40008195-CH34" target="_self">nib file</a></span>, the way you configure the actions and outlets of your view controller is essentially the same. Using Interface Builder, you create connections between the views and controls in your interface to the object representing your view controller. In an integrated nib file, you can make connections directly to the view controller object. However, in a detached nib file, you make connections to the File’s Owner placeholder, which stands in for your view controller object. </p><p><span class="content_text">Listing 2-2</span> shows the definition of a custom <code>MyViewController</code> class that defines two custom outlets (designated by the <code>IBOutlet</code> keyword) and a single action method (designated by the <code>IBAction</code> return type). The outlets store references to a button and a text field in the nib file, while the action method responds to taps in the button.</p><a name="//apple_ref/doc/uid/TP40007457-CH101-SW13" title="Listing 2-2Custom view controller class declaration"></a><p class="codesample clear"><strong>Listing 2-2&nbsp;&nbsp;</strong>Custom view controller class declaration</p><div class="codesample clear"><table><tr><td scope="row"><pre>@interface MyViewController : UIViewController<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>  id myButton;<span></span></pre></td></tr><tr><td scope="row"><pre>  id myTextField;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>@property (nonatomic) IBOutlet id myButton;<span></span></pre></td></tr><tr><td scope="row"><pre>@property (nonatomic) IBOutlet id myTextField;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (IBAction)myAction:(id)sender;<span></span></pre></td></tr></table></div><p><span class="content_text">Figure 2-6</span> shows the connections you would create among the objects in such a <code>MyViewController</code> class. This nib file is configured as per the instructions in <span class="content_text"><a href="#//apple_ref/doc/uid/TP40007457-CH101-SW11">“Configuring Actions and Outlets for Your View Controller,”</a></span> with the class of the File’s Owner placeholder set to the view controller class and the <code>view</code> outlet of File’s Owner connected to the top-level view object. The nib file also contains connections between the outlets and actions of the <code>MyViewController</code> class and the corresponding nib file objects. </p><figure><a name="//apple_ref/doc/uid/TP40007457-CH101-SW53" title="Figure 2-6Contents of MyViewController.nib"></a><figcaption><strong>Figure 2-6&nbsp;&nbsp;</strong>Contents of <code>MyViewController.nib</code></figcaption><img src="../Art/viewcontroller_nib1.jpg" alt="" width="206" height="321"></figure><p>When the previously configured <code>MyViewController</code> class is created and presented modally, the view controller infrastructure loads the nib file automatically and reconfigures any outlets or actions. Thus, by the time the view is presented to the user, the outlets and actions of your view controller are set and ready to be used. This ability to bridge between your runtime code and your design-time resource files is one of the things that makes nib files very powerful. </p></section></section><section><a name="//apple_ref/doc/uid/TP40007457-CH101-SW36" title="Creating the View Programmatically"></a><h4 class="jump">Creating the View Programmatically</h4><p>If you prefer to create views programmatically, instead of using a <span class="pediaLink" data-header="Nib file" data-contents="A nib file is a special type of resource file that you use to store the user interfaces of iOS and Mac OS X applications. "><a href="../../../documentation/General/Conceptual/DevPedia-CocoaCore/NibFile.html#//apple_ref/doc/uid/TP40008195-CH34" target="_self">nib file</a></span>, you do so from your view controller’s <code><a href="../../../documentation/UIKit/Reference/UIViewController_Class/Reference/Reference.html#//apple_ref/occ/instm/UIViewController/loadView" target="_self">loadView</a></code> method. You must <span class="pediaLink" data-header="Method overriding" data-contents="Method overriding is a language feature in which a class can provide an implementation of a method that is already provided by one of its parent classes. "><a href="../../../documentation/General/Conceptual/DevPedia-CocoaCore/MethodOverriding.html#//apple_ref/doc/uid/TP40008195-CH57" target="_self">override</a></span> this method if you plan to create your views programmatically. Your implementation of this method should do the following: </p><ol class="ol"><li class="li"><p>Create a root view object that is sized to fit the screen. </p><p>The root view acts as the container for all other views associated with your view controller. You typically define the frame for this view to match the size of the application window, which itself should fill the screen. However, the view controller also adjusts the frame size as needed to accommodate the presence of assorted views, such as the system status bar, a navigation bar, or a tab bar. </p><p>You can use a generic <code><a href="../../../documentation/UIKit/Reference/UIView_Class/UIView/UIView.html#//apple_ref/occ/cl/UIView" target="_self">UIView</a></code> object, a custom view you define, or any other view that can scale to fill the screen.</p></li><li class="li"><p>Create any additional subviews and add them to the root view. For each view, you should do the following:</p><ol class="ol"><li class="ol ol"><p>Create and initialize the view. For system views, you typically use the <code><a href="../../../documentation/UIKit/Reference/UIView_Class/UIView/UIView.html#//apple_ref/occ/instm/UIView/initWithFrame:" target="_self">initWithFrame:</a></code> method to specify the initial size and position of the view.</p></li><li class="ol ol"><p>Add the view to a parent view using the <code><a href="../../../documentation/UIKit/Reference/UIView_Class/UIView/UIView.html#//apple_ref/occ/instm/UIView/addSubview:" target="_self">addSubview:</a></code> method.</p></li><li class="ol ol"><p>Release the view by calling its <code><a href="../../../documentation/Cocoa/Reference/Foundation/Protocols/NSObject_Protocol/Reference/NSObject.html#//apple_ref/occ/intfm/NSObject/release" target="_self">release</a></code> method.</p></li></ol></li><li class="li"><p>Assign the root view to the <code><a href="../../../documentation/UIKit/Reference/UIViewController_Class/Reference/Reference.html#//apple_ref/occ/instp/UIViewController/view" target="_self">view</a></code> <span class="pediaLink" data-header="Declared property" data-contents="A declared property provides a syntactical shorthand for declaring a class’s accessor methods and, optionally, implementing them. "><a href="../../../documentation/General/Conceptual/DevPedia-CocoaCore/DeclaredProperty.html#//apple_ref/doc/uid/TP40008195-CH13" target="_self">property</a></span> of your view controller.</p></li><li class="li"><p>Release the root view.</p></li></ol><p>The notion of releasing each view shortly after creating it might sound strange, but once you add a view to your view hierarchy or save a reference to it, that is exactly what you want to do. The initial <span class="pediaLink" data-header="Memory management" data-contents="Memory management is the programming discipline of managing the life cycles of objects and freeing them when they are no longer needed. "><a href="../../../documentation/General/Conceptual/DevPedia-CocoaCore/MemoryManagement.html#//apple_ref/doc/uid/TP40008195-CH27" target="_self">retain count</a></span> of any object is 1 at creation time. Because parent views automatically retain their subviews, it is safe to release child views after they have been added to their parent. Similarly, the <code>view</code> property used to store your root view uses retain semantics to prevent the view from being released. Therefore, releasing each view transfers ownership to the appropriate place and prevents the object from being leaked later. </p><p><span class="content_text">Listing 2-3</span> shows the <code>loadView</code> method from the <code>MetronomeViewController</code> class of the sample project <em><a href="../../../samplecode/Metronome/Introduction/Intro.html#//apple_ref/doc/uid/DTS40007434" target="_self">Metronome</a></em>. This method creates a custom view and does some basic setup, including assigning the custom view to the view controller’s <code>view</code> property, which retains the view. In this example, the <code>metronomeView</code> property of the view controller is an additional property that stores a pointer to the view; however, this property uses assignment semantics to avoid potential retention problems.</p><a name="//apple_ref/doc/uid/TP40007457-CH101-SW16" title="Listing 2-3Creating views programmatically in the Metronome application"></a><p class="codesample clear"><strong>Listing 2-3&nbsp;&nbsp;</strong>Creating views programmatically in the Metronome application</p><div class="codesample clear"><table><tr><td scope="row"><pre>- (void)loadView {<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    self.wantsFullScreenLayout = YES;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    MetronomeView *view = [[MetronomeView alloc]<span></span></pre></td></tr><tr><td scope="row"><pre>                           åinitWithFrame:[UIScreen mainScreen].applicationFrame];<span></span></pre></td></tr><tr><td scope="row"><pre>    view.metronomeViewController = self;<span></span></pre></td></tr><tr><td scope="row"><pre>    self.view = view;<span></span></pre></td></tr><tr><td scope="row"><pre>    self.metronomeView = view;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    [view release];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><div class="notebox"><aside><a name="//apple_ref/doc/uid/TP40007457-CH101-SW37" title="Note"></a><p><strong>Note:</strong>&nbsp;When overriding the <code>loadView</code> method to create your views programmatically, you should not call <code>super</code>. Doing so initiates the default view-loading behavior and is usually just a waste of CPU cycles. Your own implementation of the <code>loadView</code> method should do all the work that is needed to create a root view and subviews for your view controller. For more information on the view loading process, see <span class="content_text"><a href="#//apple_ref/doc/uid/TP40007457-CH101-SW19">“Understanding the View Management Cycle.”</a></span> </p><p></p></aside></div><p>If you retain any view objects using properties or custom setter methods, you should always remember to implement a <code><a href="../../../documentation/UIKit/Reference/UIViewController_Class/Reference/Reference.html#//apple_ref/occ/instm/UIViewController/viewDidUnload" target="_self">viewDidUnload</a></code> method to set those properties to <code>nil</code>. This is especially true if you use outlets to store references to your views and those outlets use a property or other setter method with retain semantics. For more information about managing the memory associated with your views, see <span class="content_text"><a href="#//apple_ref/doc/uid/TP40007457-CH101-SW4">“Managing Memory Efficiently.”</a></span> </p></section></section><section><a name="//apple_ref/doc/uid/TP40007457-CH101-SW38" title="Cleaning Up After Unloading a View"></a><h3 class="jump">Cleaning Up After Unloading a View</h3><p>After it is loaded into memory, a view controller’s view remains in memory until a low-memory condition occurs or the view controller itself is deallocated. In the case of a low-memory condition, the default <code><a href="../../../documentation/UIKit/Reference/UIViewController_Class/Reference/Reference.html#//apple_ref/occ/cl/UIViewController" target="_self">UIViewController</a></code> behavior is to release the view object stored in the <code><a href="../../../documentation/UIKit/Reference/UIViewController_Class/Reference/Reference.html#//apple_ref/occ/instp/UIViewController/view" target="_self">view</a></code> property if that view is not currently being used. However, if your custom view controller class stores outlets or pointers to any views in the view hierarchy, you must also release those references when the top-level view object is released. Failure to do so prevents those objects from being removed from memory right away and could potentially cause memory leaks later if you subsequently overwrite any pointers to them.</p><p>There are two places where your view controller should always clean up any references to view objects:</p><ul class="ul"><li class="li"><p>The <code><a href="../../../documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/instm/NSObject/dealloc" target="_self">dealloc</a></code> method</p></li><li class="li"><p>The <code><a href="../../../documentation/UIKit/Reference/UIViewController_Class/Reference/Reference.html#//apple_ref/occ/instm/UIViewController/viewDidUnload" target="_self">viewDidUnload</a></code> method</p></li></ul><p>If you use a <span class="pediaLink" data-header="Declared property" data-contents="A declared property provides a syntactical shorthand for declaring a class’s accessor methods and, optionally, implementing them. "><a href="../../../documentation/General/Conceptual/DevPedia-CocoaCore/DeclaredProperty.html#//apple_ref/doc/uid/TP40008195-CH13" target="_self">declared property</a></span> to store a reference to your view, and that property uses retain semantics, assigning a <code>nil</code> value to it is enough to release the view. Properties are by far the preferred way to manage your view objects because of their convenience. If you do not use properties, you must send a <code>release</code> message to any view that you explicitly retained before setting the corresponding pointer value to <code>nil</code>.</p><p>For information about memory management best practices, see <span class="content_text"><a href="#//apple_ref/doc/uid/TP40007457-CH101-SW4">“Managing Memory Efficiently.”</a></span>  </p></section><section><a name="//apple_ref/doc/uid/TP40007457-CH101-SW4" title="Managing Memory Efficiently"></a><h3 class="jump">Managing Memory Efficiently</h3><p>When it comes to view controllers and <span class="pediaLink" data-header="Memory management" data-contents="Memory management is the programming discipline of managing the life cycles of objects and freeing them when they are no longer needed. "><a href="../../../documentation/General/Conceptual/DevPedia-CocoaCore/MemoryManagement.html#//apple_ref/doc/uid/TP40008195-CH27" target="_self">memory management</a></span>, there are two issues to consider: </p><ul class="ul"><li class="li"><p>How do you allocate memory efficiently?</p></li><li class="li"><p>When and how do you release memory? </p></li></ul><p>Although some aspects of memory allocation are strictly yours to decide, there are a handful of methods in the <code><a href="../../../documentation/UIKit/Reference/UIViewController_Class/Reference/Reference.html#//apple_ref/occ/cl/UIViewController" target="_self">UIViewController</a></code> class that usually have some connection to memory management tasks. <span class="content_text">Table 2-2</span> lists the places in your view controller object where you are likely to allocate or deallocate memory along with information about what you should be doing in each place.  </p><a name="//apple_ref/doc/uid/TP40007457-CH101-SW20" title="Table 2-2Places to allocate and deallocate memory "></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 2-2&nbsp;&nbsp;</strong>Places to allocate and deallocate memory </caption><tr><th scope="col" class="TableHeading_TableRow_TableCell"><p>Task</p></th><th scope="col" class="TableHeading_TableRow_TableCell"><p>Methods</p></th><th scope="col" class="TableHeading_TableRow_TableCell"><p>Discussion</p></th></tr><tr><td  scope="row"><p>Allocating critical data structures required by your view controller</p></td><td ><p>Initialization methods</p></td><td ><p>Your custom <span class="pediaLink" data-header="Initialization" data-contents="Initialization is the stage of object creation that makes a newly allocated object usable by setting its state to reasonable initial values. "><a href="../../../documentation/General/Conceptual/DevPedia-CocoaCore/Initialization.html#//apple_ref/doc/uid/TP40008195-CH21" target="_self">initialization</a></span> method (whether it is named <code>init</code> or something else) is always responsible for putting your view controller object in a known good state. This includes allocating whatever data structures are needed to ensure proper operation. </p></td></tr><tr><td  scope="row"><p>Creating your view objects</p></td><td ><p><code><a href="../../../documentation/UIKit/Reference/UIViewController_Class/Reference/Reference.html#//apple_ref/occ/instm/UIViewController/loadView" target="_self">loadView</a></code></p></td><td ><p>Overriding the <code>loadView</code> method is required only if you intend to create your views programmatically. If you are loading your views from a nib file, all you have to do is use the <code><a href="../../../documentation/UIKit/Reference/UIViewController_Class/Reference/Reference.html#//apple_ref/occ/instm/UIViewController/initWithNibName:bundle:" target="_self">initWithNibName:bundle:</a></code> method to initialize your view controller with the appropriate nib file information.  </p></td></tr><tr><td  scope="row"><p>Allocating or loading data to be displayed in your view</p></td><td ><p><code><a href="../../../documentation/UIKit/Reference/UIViewController_Class/Reference/Reference.html#//apple_ref/occ/instm/UIViewController/viewDidLoad" target="_self">viewDidLoad</a></code></p></td><td ><p>Any data that is tied to your view objects should be created or loaded in the <code>viewDidLoad</code> method. By the time this method is called, your view objects are guaranteed to exist and be in a known good state.</p></td></tr><tr><td  scope="row"><p>Releasing references to view objects</p></td><td ><p><code><a href="../../../documentation/UIKit/Reference/UIViewController_Class/Reference/Reference.html#//apple_ref/occ/instm/UIViewController/viewDidUnload" target="_self">viewDidUnload</a></code></p><p><code><a href="../../../documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/instm/NSObject/dealloc" target="_self">dealloc</a></code></p></td><td ><p>If you retain any view objects in your view hierarchy using outlets or other member variables in your class, you must always release those outlets when the views are no longer needed. After releasing a view object, always be sure to set your outlet or variable to <code>nil</code> for safety. For more information about when views get released, see <span class="content_text"><a href="#//apple_ref/doc/uid/TP40007457-CH101-SW19">“Understanding the View Management Cycle.”</a></span>  </p></td></tr><tr><td  scope="row"><p>Releasing data that is not needed when your view is not displayed</p></td><td ><p><code><a href="../../../documentation/UIKit/Reference/UIViewController_Class/Reference/Reference.html#//apple_ref/occ/instm/UIViewController/viewDidUnload" target="_self">viewDidUnload</a></code></p></td><td ><p>You can use the <code>viewDidUnload</code> method to deallocate any data that is view-specific and that can be recreated easily enough if the view is loaded into memory again. If recreating the data might be too time-consuming, though, you do not have to release the corresponding data objects here. Instead, you should consider releasing those objects in your <code>didReceiveMemoryWarning</code> method.</p></td></tr><tr><td  scope="row"><p>Responding to low-memory notifications</p></td><td ><p><code><a href="../../../documentation/UIKit/Reference/UIViewController_Class/Reference/Reference.html#//apple_ref/occ/instm/UIViewController/didReceiveMemoryWarning" target="_self">didReceiveMemoryWarning</a></code></p></td><td ><p>Use this method to deallocate all noncritical custom data structures associated with your view controller. Although you would not use this method to release references to view objects, you might use it to release any view-related data structures that you did not already release in your <code>viewDidUnload</code> method. (The view objects themselves should always be released in the <code>viewDidUnload</code> method.)</p></td></tr><tr><td  scope="row"><p>Releasing critical data structures required by your view controller</p></td><td ><p><code><a href="../../../documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/instm/NSObject/dealloc" target="_self">dealloc</a></code></p></td><td ><p>Use this method to release all data structures associated with your view controller. If your view controller still has outlets or other variables with non-<code>nil</code> values, you should release them here.</p></td></tr></table></div></section></section><section><a name="//apple_ref/doc/uid/TP40007457-CH101-SW3" title="Managing a View Controller’s Interface Orientation"></a><h2 class="jump">Managing a View Controller’s Interface Orientation</h2><p>The accelerometers in iOS–based devices make it possible to determine the current orientation of the device. The UIKit framework takes advantage of this information and uses it to orient your application’s user interface to match the device orientation when appropriate. Although applications support only a portrait orientation by default, you can configure your view controllers to support other orientations as needed. </p><p>Supporting alternate orientations requires additional configuration for both your views and the view controllers that manage them. The simplest way to support multiple interface orientations is to do the following: </p><ul class="ul"><li class="li"><p>Override your view controller’s <code><a href="../../../documentation/UIKit/Reference/UIViewController_Class/Reference/Reference.html#//apple_ref/occ/instm/UIViewController/shouldAutorotateToInterfaceOrientation:" target="_self">shouldAutorotateToInterfaceOrientation:</a></code> method and declare the orientations it supports; see <span class="content_text"><a href="#//apple_ref/doc/uid/TP40007457-CH101-SW22">“Declaring the Supported Interface Orientations.”</a></span> </p></li><li class="li"><p>Configure the autoresizing mask for each view in your view controller’s view hierarchy; see <span class="content_text"><a href="#//apple_ref/doc/uid/TP40007457-CH101-SW24">“Configuring Your Views to Support Multiple Orientations.”</a></span></p></li></ul><p>These two steps should be sufficient for many applications. However, if the autoresizing behavior of views does not yield the layout you need for each orientation, you can override additional view controller methods and use them to tweak your layout when orientation changes occur. The <code><a href="../../../documentation/UIKit/Reference/UIViewController_Class/Reference/Reference.html#//apple_ref/occ/cl/UIViewController" target="_self">UIViewController</a></code> class provides a series of notifications that let you respond to different phases of the orientation change and make adjustments to your views (or other parts of your application) as needed. These notifications are described in more detail in <span class="content_text"><a href="#//apple_ref/doc/uid/TP40007457-CH101-SW23">“Responding to Orientation Changes”</a></span></p><section><a name="//apple_ref/doc/uid/TP40007457-CH101-SW40" title="Understanding the Rotation Process"></a><h3 class="jump">Understanding the Rotation Process</h3><p>When the orientation of an iOS–based device changes, the system sends out a <code><a href="../../../documentation/UIKit/Reference/UIDevice_Class/Reference/UIDevice.html#//apple_ref/c/data/UIDeviceOrientationDidChangeNotification" target="_self">UIDeviceOrientationDidChangeNotification</a></code> notification to let any interested parties know that the change occurred. By default, the UIKit framework intercepts this notification and uses it to update your interface orientation automatically. This means that with only a few exceptions, you should not need to handle this notification at all. Instead, all you need to do is implement the appropriate methods in your view controller classes to respond to orientation changes.</p><p>In an iOS application, the window object does much of the work associated with changing the current orientation. However, it works in conjunction with the application’s view controllers to determine whether an orientation change should occur at all, and if so, what additional methods should be called to respond to the change. Specifically, it works with the view controller whose root view was most recently added to, or presented in, the window. In other words, the window object works only with the frontmost view controller whose view was displayed using one of the mechanisms described in <span class="content_text"><a href="#//apple_ref/doc/uid/TP40007457-CH101-SW25">“Presenting a View Controller’s View.”</a></span></p><p>The actual rotation process proceeds along one of two paths depending on the implementation of the associated view controller. The most common path is to perform a one-step rotation but view controllers can also support a two-step rotation if it provides a better experience. The one-step rotation process is available in iOS 3.0 and later and is preferred because it is more efficient than the two-step process. The choice as to which path is taken is dependent on your view controller subclass and which methods you <span class="pediaLink" data-header="Method overriding" data-contents="Method overriding is a language feature in which a class can provide an implementation of a method that is already provided by one of its parent classes. "><a href="../../../documentation/General/Conceptual/DevPedia-CocoaCore/MethodOverriding.html#//apple_ref/doc/uid/TP40008195-CH57" target="_self">override</a></span>. If you override any the methods associated with the one-step process, the window object uses that process; otherwise, it uses the two-step process. </p><p>Regardless of which rotation process is used, methods of the view controller are called at various stages of the rotation to give the view controller a chance to perform additional tasks. You might use these methods to hide or show views, reposition or resize views, or notify other parts of your application about the orientation change. Because your custom methods are called during the rotation operation, you should avoid performing any time-consuming operations there. You should also avoid replacing your entire view hierarchy with a new set of views. There are better ways to provide unique views for different orientations, such as presenting a new view controller modally (as described in <span class="content_text"><a href="#//apple_ref/doc/uid/TP40007457-CH101-SW26">“Creating an Alternate Landscape Interface”</a></span>). </p><p>For detailed information about the sequence of steps that occur during the one-step and two-step rotation processes, see <span class="content_text"><a href="#//apple_ref/doc/uid/TP40007457-CH101-SW23">“Responding to Orientation Changes.”</a></span>  </p></section><section><a name="//apple_ref/doc/uid/TP40007457-CH101-SW22" title="Declaring the Supported Interface Orientations"></a><h3 class="jump">Declaring the Supported Interface Orientations</h3><p>If the view managed by your view controller supports orientations other than the default portrait orientation, you must override the <code>shouldAutorotateToInterfaceOrientation:</code> method and indicate which orientations your view supports. You should always choose the orientations your view supports at design time and implement your code with those orientations in mind. There is no benefit to choosing which orientations you want to support dynamically based on runtime information. Even if you did so, you would still have to implement the necessary code to support all possible orientations, and so you might as well just choose to support the orientation or not up front. </p><p><span class="content_text">Listing 2-4</span> shows a fairly typical implementation of the <code>shouldAutorotateToInterfaceOrientation:</code> method for a view controller that supports the default portrait orientation and the landscape-left orientation. Your own implementation of this method should be just as simple. </p><a name="//apple_ref/doc/uid/TP40007457-CH101-SW10" title="Listing 2-4Implementing the shouldAutorotateToInterfaceOrientation: method"></a><p class="codesample clear"><strong>Listing 2-4&nbsp;&nbsp;</strong>Implementing the <code>shouldAutorotateToInterfaceOrientation:</code> method</p><div class="codesample clear"><table><tr><td scope="row"><pre>- (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)orientation<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>   if ((orientation == UIInterfaceOrientationPortrait) ||<span></span></pre></td></tr><tr><td scope="row"><pre>       (orientation == UIInterfaceOrientationLandscapeLeft))<span></span></pre></td></tr><tr><td scope="row"><pre>      return YES;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>   return NO;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><div class="importantbox clear"><aside><a name="//apple_ref/doc/uid/TP40007457-CH101-DontLinkElementID_5" title="Important:"></a><p><strong>Important:</strong>&nbsp;You must always return YES for at least one interface orientation. </p><p></p></aside></div><p>If your application supports both landscape orientations, you can use the <code><a href="../../../documentation/UIKit/Reference/UIKitFunctionReference/Reference/reference.html#//apple_ref/c/macro/UIInterfaceOrientationIsLandscape" target="_self">UIInterfaceOrientationIsLandscape</a></code> macro as a shortcut, instead of explicitly comparing the <em>orientation</em> parameter against both landscape constants. The UIKit framework similarly defines a <code><a href="../../../documentation/UIKit/Reference/UIKitFunctionReference/Reference/reference.html#//apple_ref/c/macro/UIInterfaceOrientationIsPortrait" target="_self">UIInterfaceOrientationIsPortrait</a></code> macro to identify both variants of the portrait orientation.</p></section><section><a name="//apple_ref/doc/uid/TP40007457-CH101-SW24" title="Configuring Your Views to Support Multiple Orientations"></a><h3 class="jump">Configuring Your Views to Support Multiple Orientations</h3><p>When the user interface changes orientation, the bounds of the affected views are modified automatically according to their autoresizing mask. The <code><a href="../../../documentation/UIKit/Reference/UIView_Class/UIView/UIView.html#//apple_ref/occ/instp/UIView/autoresizingMask" target="_self">autoresizingMask</a></code> property of every view contains constants that describe how the bounds of that view change in relation to its superview. Each view adjusts its own bounds and then asks each of its subviews to resize itself based on its autoresizing behaviors. The net result is that if you configure the autoresizing behaviors of your views appropriately, your views can adjust to orientation changes automatically. </p><p>If the autoresizing behaviors of views do not provide the precise layout you need, you may want to replace or supplement their behavior by providing your own custom layout code. The <code><a href="../../../documentation/UIKit/Reference/UIViewController_Class/Reference/Reference.html#//apple_ref/occ/cl/UIViewController" target="_self">UIViewController</a></code> class defines several methods that are called before, during, and after an orientation change. You can use these methods to modify the layout of your views as needed.  </p><p>For information about the methods that are called during the rotation process, see <span class="content_text"><a href="#//apple_ref/doc/uid/TP40007457-CH101-SW23">“Responding to Orientation Changes.”</a></span> For more information on the autoresizing properties of views and how they affect the view, see <em><a href="../../../documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/Introduction/Introduction.html#//apple_ref/doc/uid/TP40009503" target="_self">View Programming Guide for iOS</a></em>. </p></section><section><a name="//apple_ref/doc/uid/TP40007457-CH101-SW23" title="Responding to Orientation Changes"></a><h3 class="jump">Responding to Orientation Changes</h3><p>When the orientation of a device changes, view controllers can respond by making a corresponding change to the orientation of their view. If the new orientation is supported, the view controller generates notifications as it makes the change to give your code a chance to respond. Rotation notifications can occur as a one-step or two-step process.</p><p>The reason you might want to respond to orientation changes is to make adjustments to your view hierarchy. For example, you might use these notifications to make the following types of changes:</p><ul class="ul"><li class="li"><p>Show or hide views that are specific to a particular orientation.</p></li><li class="li"><p>Adjust the position or size of views based on the new orientation.</p></li><li class="li"><p>Update other parts of your application to reflect the orientation change.</p></li></ul><p>Whenever possible, the UIKit framework uses the one-step rotation process to rotate your views. However, whether it actually uses the one-step or two-step process is up to you. There are methods used by the two-step process that are not used by the one-step process, and vice versa; if you override any of the one-step methods, the one-step process is used. If you override only methods that are used by the two-step process, that process is used. The following sections describe the methods associated with each process. You can also find information about these methods (including whether they trigger the one-step or two-step process) in <em><a href="../../../documentation/UIKit/Reference/UIViewController_Class/Reference/Reference.html#//apple_ref/doc/uid/TP40006926" target="_self">UIViewController Class Reference</a></em>.</p><section><a name="//apple_ref/doc/uid/TP40007457-CH101-SW42" title="Responding to Orientation Changes in One Step"></a><h4 class="jump">Responding to Orientation Changes in One Step</h4><p>In iOS 3.0 and later, you can use one-step rotation methods to make changes just before and just after the orientation change occurs. During this process, the following sequence of events occurs: </p><ol class="ol"><li class="li"><p>The window detects that a change in the device orientation has occurred.</p></li><li class="li"><p>The window looks for an appropriate view controller and calls its <code><a href="../../../documentation/UIKit/Reference/UIViewController_Class/Reference/Reference.html#//apple_ref/occ/instm/UIViewController/shouldAutorotateToInterfaceOrientation:" target="_self">shouldAutorotateToInterfaceOrientation:</a></code> method to determine if it supports the new orientation.</p><p>Container view controllers may intercept this method and use their own heuristics to determine whether the orientation change should occur. For example, the tab bar controller allows orientation changes only if all of its managed view controllers support the new orientation.</p></li><li class="li"><p>If the new orientation is supported, the window calls the view controller’s <code><a href="../../../documentation/UIKit/Reference/UIViewController_Class/Reference/Reference.html#//apple_ref/occ/instm/UIViewController/willRotateToInterfaceOrientation:duration:" target="_self">willRotateToInterfaceOrientation:duration:</a></code> method.</p><p>Container view controllers forward this message on to the currently displayed custom view controller. You can override this method in your custom view controllers to hide views or make other changes to your view layout before the interface is rotated. </p></li><li class="li"><p>The window adjusts the bounds of the view controller’s view. </p><p>This causes each view in the view hierarchy to be resized based on its autoresizing mask. </p></li><li class="li"><p>The window calls the view controller’s <code><a href="../../../documentation/UIKit/Reference/UIViewController_Class/Reference/Reference.html#//apple_ref/occ/instm/UIViewController/didRotateFromInterfaceOrientation:" target="_self">didRotateFromInterfaceOrientation:</a></code> method.</p><p>Container view controllers forward this message to the currently displayed custom view controller. This marks the end of the rotation process. You can use this method to show views, change the layout of views, or make other changes to your application.</p></li></ol><p><span class="content_text">Figure 2-7</span> shows a visual representation of the preceding steps. It also shows how the interface would look at various stages of the process.  </p><figure><a name="//apple_ref/doc/uid/TP40007457-CH101-SW9" title="Figure 2-7Processing a one-step interface rotation"></a><figcaption><strong>Figure 2-7&nbsp;&nbsp;</strong>Processing a one-step interface rotation</figcaption><img src="../Art/rotation_onestep.jpg" alt="" width="531" height="593"></figure></section><section><a name="//apple_ref/doc/uid/TP40007457-CH101-SW43" title="Responding to Orientation Changes in Two Steps"></a><h4 class="jump">Responding to Orientation Changes in Two Steps</h4><p>In all versions of iOS, you can use two-step notifications to respond to interface orientation changes. In the two-step process, two separate rotations occur. During the first step, the interface is rotated only halfway to its destination. During the second step, the rotation is rotated from this midpoint to its final orientation. Your application receives notifications throughout the process that allow you to respond before, during, and after the rotation. </p><p>The following sequence of events occurs during a two-step rotation: </p><ol class="ol"><li class="li"><p>The window detects that a change in the device orientation has occurred.</p></li><li class="li"><p>The window looks for an appropriate view controller and calls its <code><a href="../../../documentation/UIKit/Reference/UIViewController_Class/Reference/Reference.html#//apple_ref/occ/instm/UIViewController/shouldAutorotateToInterfaceOrientation:" target="_self">shouldAutorotateToInterfaceOrientation:</a></code> method to determine if it supports the new orientation.</p><p>Container view controllers may intercept this method and use their own heuristics to determine whether the orientation change should occur. For example, the tab bar controller allows orientation changes only if all of its managed view controllers support the new orientation.</p></li><li class="li"><p>If the new orientation is supported, the window calls the view controller’s  <code><a href="../../../documentation/UIKit/Reference/UIViewController_Class/Reference/Reference.html#//apple_ref/occ/instm/UIViewController/willRotateToInterfaceOrientation:duration:" target="_self">willRotateToInterfaceOrientation:duration:</a></code> method.</p><p>Container view controllers forward this message to the currently displayed custom view controller. You can use this method to hide views or make other changes to your view layout before the interface is rotated. </p></li><li class="li"><p>The window calls the view controller’s <code><a href="../../../documentation/UIKit/Reference/UIViewController_Class/Reference/Reference.html#//apple_ref/occ/instm/UIViewController/willAnimateFirstHalfOfRotationToInterfaceOrientation:duration:" target="_self">willAnimateFirstHalfOfRotationToInterfaceOrientation:duration:</a></code> method. </p><p>Container view controllers forward this message to the currently displayed custom view controller. You can use this method to hide views or make other changes to your view layout before the interface is rotated. </p></li><li class="li"><p>The window performs the first half of the rotation.</p><p>This causes the bounds of each view in the view hierarchy to be adjusted based on its autoresizing behaviors. Although most rotations involve moving from portrait to landscape mode (and thus rotating 45 degrees to the halfway point), it is possible to rotate from a landscape left to landscape right orientation or from a portrait to upside down portrait orientation. In these latter cases, the first half of the rotation would be 90 degrees.</p></li><li class="li"><p>The window calls the view controller’s <code><a href="../../../documentation/UIKit/Reference/UIViewController_Class/Reference/Reference.html#//apple_ref/occ/instm/UIViewController/didAnimateFirstHalfOfRotationToInterfaceOrientation:" target="_self">didAnimateFirstHalfOfRotationToInterfaceOrientation:</a></code> method.</p><p>Container view controllers forward this message to the currently displayed custom view controller.</p></li><li class="li"><p>The window calls the view controller’s <code><a href="../../../documentation/UIKit/Reference/UIViewController_Class/Reference/Reference.html#//apple_ref/occ/instm/UIViewController/willAnimateSecondHalfOfRotationFromInterfaceOrientation:duration:" target="_self">willAnimateSecondHalfOfRotationFromInterfaceOrientation:duration:</a></code> method.</p><p>Container view controllers forward this message to the currently displayed custom view controller.</p></li><li class="li"><p>The window performs the second half of the rotation. </p><p>By the end of this rotation, the autoresizing behaviors for all views have been applied and the views are in their “final” position.</p></li><li class="li"><p>The window calls the view controller’s <code><a href="../../../documentation/UIKit/Reference/UIViewController_Class/Reference/Reference.html#//apple_ref/occ/instm/UIViewController/didRotateFromInterfaceOrientation:" target="_self">didRotateFromInterfaceOrientation:</a></code> method.</p><p>Container view controllers forward this message to the currently displayed custom view controller. You can use this method to show views, reposition or resize views, or make other changes once the rotation has finished.</p></li></ol><p><span class="content_text">Figure 2-8</span> shows a visual representation of the preceding steps. Along with each step, it shows how the view would appear to the user. </p><figure><a name="//apple_ref/doc/uid/TP40007457-CH101-SW18" title="Figure 2-8Processing a two-step interface rotation"></a><figcaption><strong>Figure 2-8&nbsp;&nbsp;</strong>Processing a two-step interface rotation</figcaption><img src="../Art/rotation_twostep.jpg" alt="" width="597" height="874"></figure></section></section><section><a name="//apple_ref/doc/uid/TP40007457-CH101-SW26" title="Creating an Alternate Landscape Interface"></a><h3 class="jump">Creating an Alternate Landscape Interface</h3><p>If you want to present the same data differently based on whether a device is in a portrait or landscape orientation, the way to do so is using two separate view controllers. One view controller should manage the display of the data in the primary orientation (typically portrait) while the other manages the display of the data in the alternate orientation. Using two view controllers is simpler and more efficient than making major changes to your view hierarchy each time the orientation changes. It allows each view controller to focus on the presentation of data in one orientation and to manage things accordingly. It also eliminates the need to litter your view controller code with conditional checks for the current orientation.</p><p>In order to support an alternate landscape interface, you have to do the following: </p><ul class="ul"><li class="li"><p>Implement two view controller objects:</p><ul class="nested"><li class="nested li"><p>One should present a portrait-only interface. </p></li><li class="nested li"><p>One should present a landscape-only interface.</p></li></ul></li><li class="li"><p>Register for the <code><a href="../../../documentation/UIKit/Reference/UIDevice_Class/Reference/UIDevice.html#//apple_ref/c/data/UIDeviceOrientationDidChangeNotification" target="_self">UIDeviceOrientationDidChangeNotification</a></code> notification. In your handler method, present or dismiss the alternate view controller based on the current device orientation.</p></li></ul><p>Because view controllers normally manage orientation changes internally, you have to tell each view controller to display itself in one orientation only. The implementation of the primary view controller then needs to detect device orientation changes and present the alternate view controller when the appropriate orientation change occurs. When the orientation returns to the primary orientation, the primary view controller would then dismiss the alternate view controller. </p><p><span class="content_text">Listing 2-5</span> shows the key methods you would need to implement in a primary view controller that supports a portrait orientation. As part of its initialization, this view controller registers to receive orientation changed notifications from the shared <code><a href="../../../documentation/UIKit/Reference/UIDevice_Class/Reference/UIDevice.html#//apple_ref/occ/cl/UIDevice" target="_self">UIDevice</a></code> object. When such a notification arrives, the <code>orientationChanged:</code> method then presents or dismisses the landscape view controller depending on the current orientation. </p><a name="//apple_ref/doc/uid/TP40007457-CH101-SW47" title="Listing 2-5Presenting the landscape view controller"></a><p class="codesample clear"><strong>Listing 2-5&nbsp;&nbsp;</strong>Presenting the landscape view controller</p><div class="codesample clear"><table><tr><td scope="row"><pre>@implementation PortraitViewController<span></span></pre></td></tr><tr><td scope="row"><pre>- (id)init<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>   self = [super initWithNibName:@"PortraitView" bundle:nil];<span></span></pre></td></tr><tr><td scope="row"><pre>   if (self)<span></span></pre></td></tr><tr><td scope="row"><pre>   {<span></span></pre></td></tr><tr><td scope="row"><pre>       isShowingLandscapeView = NO;<span></span></pre></td></tr><tr><td scope="row"><pre>       self.landscapeViewController = [[[LandscapeViewController alloc]<span></span></pre></td></tr><tr><td scope="row"><pre>                            initWithNibName:@"LandscapeView" bundle:nil] autorelease];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>       [[UIDevice currentDevice] beginGeneratingDeviceOrientationNotifications];<span></span></pre></td></tr><tr><td scope="row"><pre>       [[NSNotificationCenter defaultCenter] addObserver:self<span></span></pre></td></tr><tr><td scope="row"><pre>                                 selector:@selector(orientationChanged:)<span></span></pre></td></tr><tr><td scope="row"><pre>                                 name:UIDeviceOrientationDidChangeNotification<span></span></pre></td></tr><tr><td scope="row"><pre>                                 object:nil];<span></span></pre></td></tr><tr><td scope="row"><pre>   }<span></span></pre></td></tr><tr><td scope="row"><pre>   return self;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)orientationChanged:(NSNotification *)notification<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    UIDeviceOrientation deviceOrientation = [UIDevice currentDevice].orientation;<span></span></pre></td></tr><tr><td scope="row"><pre>    if (UIDeviceOrientationIsLandscape(deviceOrientation) &amp;&amp;<span></span></pre></td></tr><tr><td scope="row"><pre>        !isShowingLandscapeView)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        [self presentModalViewController:self.landscapeViewController<span></span></pre></td></tr><tr><td scope="row"><pre>                                animated:YES];<span></span></pre></td></tr><tr><td scope="row"><pre>        isShowingLandscapeView = YES;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    else if (UIDeviceOrientationIsPortrait(deviceOrientation) &amp;&amp;<span></span></pre></td></tr><tr><td scope="row"><pre>             isShowingLandscapeView)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        [self dismissModalViewControllerAnimated:YES];<span></span></pre></td></tr><tr><td scope="row"><pre>        isShowingLandscapeView = NO;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div></section><section><a name="//apple_ref/doc/uid/TP40007457-CH101-SW41" title="Tips for Implementing Your Rotation Code"></a><h3 class="jump">Tips for Implementing Your Rotation Code</h3><p>Depending on the complexity of your views, you may need to write a lot of code to support rotations or none at all. When figuring out what you need to do, you can use the following tips as a guide for writing your code.</p><ul class="ul"><li class="li"><p><strong>Disable event delivery temporarily during rotations.</strong> Disabling event delivery for your views prevents unwanted code from executing while an orientation change is in progress.</p></li><li class="li"><p><strong>Store the visible map region.</strong> If your application contains a map view, save the visible map region value prior to the beginning of rotations. When the rotations finish, use the saved value as needed to ensure that the displayed region is approximately the same as before.</p></li><li class="li"><p><strong>For complex view hierarchies, replace your views with a snapshot image.</strong> If animating large numbers of views is causing performance issues, temporarily replace those views with an image view containing an image of the views instead. Once the rotations are complete, reinstall your views and remove the image view. </p></li><li class="li"><p><strong>Reload the contents of any visible tables after a rotation.</strong> Forcing a reload operation when the rotations are finished ensures that any new table rows exposed are filled appropriately.  </p></li><li class="li"><p><strong>Use rotation notifications to update your application’s state information.</strong> If your application uses the current orientation to determine how to present content, use the rotation methods of your view controller (or the corresponding device orientation notifications) to note those changes and make any necessary adjustments. </p></li></ul></section></section><section><a name="//apple_ref/doc/uid/TP40007457-CH101-SW54" title="Creating Custom View Controller Objects at Runtime"></a><h2 class="jump">Creating Custom View Controller Objects at Runtime</h2><p>There are two ways to create a custom view controller object: programmatically or using a <span class="pediaLink" data-header="Nib file" data-contents="A nib file is a special type of resource file that you use to store the user interfaces of iOS and Mac OS X applications. "><a href="../../../documentation/General/Conceptual/DevPedia-CocoaCore/NibFile.html#//apple_ref/doc/uid/TP40008195-CH34" target="_self">nib file</a></span>. Which technique you should use depends on the structure of your user interface. For complex interfaces that incorporate tab bar controllers and navigation controllers, you usually include at least a few custom view controllers in your application’s main nib file and create the rest programmatically. In most other situations, you should create view controllers programmatically and only as they are needed.</p><p>To create a custom view controller programmatically, you could use code similar to the following:</p><div class="codesample clear"><table><tr><td scope="row"><pre>MyViewController* vc = [[MyViewController alloc] initWithNibName:@"MyViewController"<span></span></pre></td></tr><tr><td scope="row"><pre>                             bundle:nil];<span></span></pre></td></tr></table></div><p>Such an example assumes that your view controller does not perform any significant <span class="pediaLink" data-header="Initialization" data-contents="Initialization is the stage of object creation that makes a newly allocated object usable by setting its state to reasonable initial values. "><a href="../../../documentation/General/Conceptual/DevPedia-CocoaCore/Initialization.html#//apple_ref/doc/uid/TP40008195-CH21" target="_self">initialization</a></span>, or if it does, it does so in an <span class="pediaLink" data-header="Method overriding" data-contents="Method overriding is a language feature in which a class can provide an implementation of a method that is already provided by one of its parent classes. "><a href="../../../documentation/General/Conceptual/DevPedia-CocoaCore/MethodOverriding.html#//apple_ref/doc/uid/TP40008195-CH57" target="_self">overridden</a></span> version of the <code><a href="../../../documentation/UIKit/Reference/UIViewController_Class/Reference/Reference.html#//apple_ref/occ/instm/UIViewController/initWithNibName:bundle:" target="_self">initWithNibName:bundle:</a></code> method. A common approach to take when designing custom view controllers though is to define one or more custom initialization methods. Doing so allows you to hide some of the more immutable aspects of the view controller initialization (such as specifying the nib file and bundle names) and focus instead on the data you want to use to initialize the view controller. For example, a custom initialization method that takes an array of objects might look something like the following:</p><div class="codesample clear"><table><tr><td scope="row"><pre>- (id)initWithData:(NSArray*)data {<span></span></pre></td></tr><tr><td scope="row"><pre>    if ((self = [super initWithNibName:@"MyViewController" bundle:nil])) {<span></span></pre></td></tr><tr><td scope="row"><pre>        // Initialize the view controller with the starting data<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return self;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Using such an initialization method, you would create and initialize the view controller so that it is immediately ready for use. You could then present the view controller or add it to a navigation interface. For example, to present the new view controller modally, you might define a method similar to the following on the current view controller: </p><div class="codesample clear"><table><tr><td scope="row"><pre>- (void)presentModalViewControllerWithData:(NSArray*)data {<span></span></pre></td></tr><tr><td scope="row"><pre>   MyViewController* vc = [[MyViewController alloc] initWithData:data];<span></span></pre></td></tr><tr><td scope="row"><pre>   [self presentModalViewController:vc animated:YES];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>When creating view controllers programmatically, it is your responsibility to set the frame of the view controller’s view appropriately before using the view. A programmatically created view controller that loads its view from a nib file does not try to change the size or position of that view. If the view controller is presented modally or used with a container view controller, the parent or container view controller often adjusts the view for you. But in cases where you add the view to a window yourself, the view’s existing frame is used as is. If your application has a status bar, failing to adjust the view’s frame could cause the misplacement of the view underneath the status bar.</p><p>The process for creating view controllers using a nib file is somewhat more involved and is described in <span class="content_text"><a href="#//apple_ref/doc/uid/TP40007457-CH101-SW34">“Storing the View and View Controller in the Same Nib File.”</a></span> For information on how to display your view controller’s view at runtime, see <span class="content_text"><a href="#//apple_ref/doc/uid/TP40007457-CH101-SW25">“Presenting a View Controller’s View.”</a></span> </p></section><section><a name="//apple_ref/doc/uid/TP40007457-CH101-SW25" title="Presenting a View Controller’s View"></a><h2 class="jump">Presenting a View Controller’s View</h2><p>There are several options for displaying the view associated with a view controller: </p><ul class="ul"><li class="li"><p>Display the view directly by adding it to a window using the <code><a href="../../../documentation/UIKit/Reference/UIView_Class/UIView/UIView.html#//apple_ref/occ/instm/UIView/addSubview:" target="_self">addSubview:</a></code> method.</p></li><li class="li"><p>Display the view indirectly using one of the following techniques:</p><ul class="nested"><li class="nested li"><p>Present the owning view controller modally using the <code><a href="../../../documentation/UIKit/Reference/UIViewController_Class/Reference/Reference.html#//apple_ref/occ/instm/UIViewController/presentModalViewController:animated:" target="_self">presentModalViewController:animated:</a></code> method.</p></li><li class="nested li"><p>Push the owning view controller onto the navigation stack of a navigation controller object.</p></li><li class="nested li"><p>Make the owning view controller the root view controller of a tab in a tab bar interface. </p></li><li class="nested li"><p>On iPad, present the view controller using a popover.</p></li></ul></li></ul><p><span class="content_text">Listing 2-6</span> shows an example of how to display a view directly in the application’s main window. In this example, the <code>viewController</code> variable is an outlet that stores a pointer to a view controller loaded from the main nib file. Similarly, the <code>window</code> variable stores a pointer to the application window. (This exact code is created for you in your application delegate when you use the View-based Application project template.) Adding the view to the window loads the view and causes it to be displayed when the window is subsequently shown.</p><a name="//apple_ref/doc/uid/TP40007457-CH101-SW17" title="Listing 2-6Adding a view controller’s view to a window"></a><p class="codesample clear"><strong>Listing 2-6&nbsp;&nbsp;</strong>Adding a view controller’s view to a window</p><div class="codesample clear"><table><tr><td scope="row"><pre>- (void)applicationDidFinishLaunching:(UIApplication *)application {<span></span></pre></td></tr><tr><td scope="row"><pre>   // At this point, the main nib file is loaded.<span></span></pre></td></tr><tr><td scope="row"><pre>   // It is a good idea to set the view's frame before adding it to a window.<span></span></pre></td></tr><tr><td scope="row"><pre>   [viewController.view setFrame:[[UIScreen mainScreen] applicationFrame]];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>   [window addSubview:viewController.view];<span></span></pre></td></tr><tr><td scope="row"><pre>   [window makeKeyAndVisible];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><div class="importantbox clear"><aside><a name="//apple_ref/doc/uid/TP40007457-CH101-DontLinkElementID_6" title="Important:"></a><p><strong>Important:</strong>&nbsp;If you plan to add a view to a window using the <code>addSubview:</code> method, it is recommended that you explicitly set the frame of the view after loading it from a nib file. Although nib files store the most appropriate size for root views, setting the frame explicitly guarantees that your view is sized and positioned correctly within the window. If you plan to present a view modally or use it in conjunction with a container view controller, you do not need to set the frame explicitly. However, if you create your view controller object programmatically, you should always set the frame of its view before use.</p><p></p></aside></div><p>It is recommended that you use only the suggested techniques for displaying the views of your view controllers. In order to present and manage views properly, the system makes a note of each view (and its associated view controller) that you display directly or indirectly. It uses this information later to report view controller-related events to your application. For example, when the device orientation changes, a window uses this information to identify the frontmost view controller and notify it of the change. If you incorporate a view controller’s view into your hierarchy by other means (by adding it as a subview to some other view perhaps), the system assumes you want to manage the view yourself and does not send messages to the associated view controller object.  </p><p>Apart from your setting up your application’s initial interface, most other views are presented indirectly through their view controller objects. For information about how to present views indirectly, consult the following sections: </p><ul class="ul"><li class="li"><p>For information about how to present a view modally, see <span class="content_text"><a href="../ModalViewControllers/ModalViewControllers.html#//apple_ref/doc/uid/TP40007457-CH111-SW3">“Presenting a View Controller Modally.”</a></span> </p></li><li class="li"><p>For information about how to display views in a navigation interface, see <span class="content_text"><a href="../NavigationControllers/NavigationControllers.html#//apple_ref/doc/uid/TP40007457-CH103-SW12">“Modifying the Navigation Stack.”</a></span>  </p></li><li class="li"><p>For information about displaying a view in a tab, see <span class="content_text"><a href="../TabBarControllers/TabBarControllers.html#//apple_ref/doc/uid/TP40007457-CH102-SW2">“Creating a Tab Bar Interface.”</a></span> </p></li><li class="li"><p>For information about displaying a view using a popover, see <span class="content_text"><a href="../iPadControllers/iPadControllers.html#//apple_ref/doc/uid/TP40007457-CH6-SW7">“Creating and Presenting a Popover.”</a></span> </p></li></ul></section><section><a name="//apple_ref/doc/uid/TP40007457-CH101-SW39" title="Responding to Display-Related Notifications"></a><h2 class="jump">Responding to Display-Related Notifications</h2><p>When the visibility of a view controller’s view changes, the view controller calls some built-in methods to notify subclassers of the changes. You can use these built-in methods to respond to the change in visibility appropriately. For example, you could use these notifications to change the color and orientation of the status bar so that it matches the presentation style of the view that is about to be displayed. A view controller calls different methods depending on whether a view is about to appear or disappear from the screen.</p><p><span class="content_text">Figure 2-9</span> shows the basic sequence of events that occurs when a view controller’s view is added to a window. (If the view is already in a window but currently hidden by another view, this same sequence of events occurs when those obstructions are removed and the view is once again revealed.) The <code><a href="../../../documentation/UIKit/Reference/UIViewController_Class/Reference/Reference.html#//apple_ref/occ/instm/UIViewController/viewWillAppear:" target="_self">viewWillAppear:</a></code> and <code><a href="../../../documentation/UIKit/Reference/UIViewController_Class/Reference/Reference.html#//apple_ref/occ/instm/UIViewController/viewDidAppear:" target="_self">viewDidAppear:</a></code> methods give subclasses a chance to perform any additional actions related to the appearance of the view. </p><figure><a name="//apple_ref/doc/uid/TP40007457-CH101-SW8" title="Figure 2-9Responding to the appearance of a view"></a><figcaption><strong>Figure 2-9&nbsp;&nbsp;</strong>Responding to the appearance of a view</figcaption><img src="../Art/viewappear_process.jpg" alt="" width="535" height="405"></figure><p><span class="content_text">Figure 2-10</span> shows the basic sequence of events that occurs when a view is removed from its window. (This same sequence of events occurs when a view becomes completely hidden by another view, such as can occur when presenting new view controllers on top of the existing one.) When the view controller detects that its view is about to be removed or hidden, it calls the <code><a href="../../../documentation/UIKit/Reference/UIViewController_Class/Reference/Reference.html#//apple_ref/occ/instm/UIViewController/viewWillDisappear:" target="_self">viewWillDisappear:</a></code> and <code><a href="../../../documentation/UIKit/Reference/UIViewController_Class/Reference/Reference.html#//apple_ref/occ/instm/UIViewController/viewDidDisappear:" target="_self">viewDidDisappear:</a></code> methods to give subclasses a chance to perform any relevant tasks.</p><figure><a name="//apple_ref/doc/uid/TP40007457-CH101-SW7" title="Figure 2-10Responding to the disappearance of a view"></a><figcaption><strong>Figure 2-10&nbsp;&nbsp;</strong>Responding to the disappearance of a view</figcaption><img src="../Art/viewdisappear_process.jpg" alt="" width="466" height="405"></figure></section><section><a name="//apple_ref/doc/uid/TP40007457-CH101-SW28" title="Adopting a Full-Screen Layout for Custom Views"></a><h2 class="jump">Adopting a Full-Screen Layout for Custom Views</h2><p>If your application displays the status bar, the <code><a href="../../../documentation/UIKit/Reference/UIViewController_Class/Reference/Reference.html#//apple_ref/occ/cl/UIViewController" target="_self">UIViewController</a></code> class automatically shrinks its view so that the view does not underlap the status bar. After all, if the status bar is opaque, there is no way to see the content lying underneath or interact with it. However, if your application displays a translucent status bar, you can set the value of your view controller’s <code><a href="../../../documentation/UIKit/Reference/UIViewController_Class/Reference/Reference.html#//apple_ref/occ/instp/UIViewController/wantsFullScreenLayout" target="_self">wantsFullScreenLayout</a></code> property to <code>YES</code> to allow your view to underlap the status bar.</p><p>Underlapping the status bar is useful in situations where you want to maximize the amount of space available for displaying your content. When displaying content under the status bar, you should be sure to put that content inside a scroll view so that the user can scroll it out from under the status bar. Being able to scroll your content is important because the user cannot interact with content that is positioned behind the status bar or any other translucent views (such as translucent navigation bars and toolbars). Navigation bars automatically add a scroll content inset to your scroll view (assuming it is the root view of your view controller) to account for the height of the navigation bar; otherwise, you must modify the <code><a href="../../../documentation/UIKit/Reference/UIScrollView_Class/Reference/UIScrollView.html#//apple_ref/occ/instp/UIScrollView/contentInset" target="_self">contentInset</a></code> property of your scroll view manually.</p><p>For more information about adopting a full-screen layout for view controllers used in conjunction with a navigation controller, see <span class="content_text"><a href="../NavigationControllers/NavigationControllers.html#//apple_ref/doc/uid/TP40007457-CH103-SW9">“Adopting a Full-Screen Layout for Navigation Views.”</a></span> </p></section><section><a name="//apple_ref/doc/uid/TP40007457-CH101-SW30" title="Enabling Edit Mode for a View"></a><h2 class="jump">Enabling Edit Mode for a View</h2><p>If you want to use the same view controller to display and edit content, you can override the <code><a href="../../../documentation/UIKit/Reference/UIViewController_Class/Reference/Reference.html#//apple_ref/occ/instm/UIViewController/setEditing:animated:" target="_self">setEditing:animated:</a></code> method and use it to toggle the view controller’s view between display and edit modes. When called, your implementation of this method should add, hide, and adjust the view controller’s views to match the specified mode. For example, you might want to change the content or appearance of views to convey that the view is now editable. If your view controller manages a table, you can also call the table’s own <code>setEditing:animated:</code> method to put the table into the appropriate mode. </p><div class="notebox"><aside><a name="//apple_ref/doc/uid/TP40007457-CH101-SW55" title="Note"></a><p><strong>Note:</strong>&nbsp;You typically do not swap out your entire view hierarchy when toggling back and forth between display and edit modes. In fact, the whole point of using the <code>setEditing:animated:</code> method is so that you can make small changes to existing views. If you would prefer to display a new set of views for editing, you should either present a new view controller modally or use a navigation controller to present the new views.  </p><p></p></aside></div><p><span class="content_text">Figure 2-11</span> shows a view from the Contacts application that supports in-place editing. Tapping the Edit button in the upper-right corner tells the view controller to update itself for editing; the Done button returns the user to display mode. In addition to modifying the table, the view also changes the content of the image view and the view displaying the user’s name. It also configures the assorted views and cells so that tapping them edits their contents instead of performing other actions. </p><figure><a name="//apple_ref/doc/uid/TP40007457-CH101-SW29" title="Figure 2-11Display and edit modes of a view"></a><figcaption><strong>Figure 2-11&nbsp;&nbsp;</strong>Display and edit modes of a view</figcaption><img src="../Art/editmode.jpg" alt="" width="637" height="608"></figure><p>The implementation of your own <code>setEditing:animated:</code> method is relatively straightforward. All you have to do is check to see which mode your view controller is entering and adjust the contents of your view accordingly. </p><div class="codesample clear"><table><tr><td scope="row"><pre>- (void)setEditing:(BOOL)flag animated:(BOOL)animated<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [super setEditing:flag animated:animated];<span></span></pre></td></tr><tr><td scope="row"><pre>    if (flag == YES){<span></span></pre></td></tr><tr><td scope="row"><pre>        // change views to edit mode<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    else {<span></span></pre></td></tr><tr><td scope="row"><pre>        // save the changes if needed and change views to noneditable<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>A common place in which to use an editable view is in a navigation interface. When implementing your navigation interface, you can include a special Edit button in the navigation bar when your editable view controller is visible. (You can get this button by calling the <code><a href="../../../documentation/UIKit/Reference/UIViewController_Class/Reference/Reference.html#//apple_ref/occ/instm/UIViewController/editButtonItem" target="_self">editButtonItem</a></code> method of your view controller.) When tapped, this button automatically toggles between an Edit and Done button and calls your view controller’s <code>setEditing:animated:</code> method with appropriate values. You can also call this method from your own code (or modify the value of your view controller’s <code><a href="../../../documentation/UIKit/Reference/UIViewController_Class/Reference/Reference.html#//apple_ref/occ/instp/UIViewController/editing" target="_self">editing</a></code> property) to toggle between modes. </p><p>For more information about adding an Edit button to a navigation bar, see <span class="content_text"><a href="../NavigationControllers/NavigationControllers.html#//apple_ref/doc/uid/TP40007457-CH103-SW18">“Using Edit and Done Buttons.”</a></span> For more information about how you support the editing of table views, see <em><a href="../../../documentation/UserExperience/Conceptual/TableView_iPhone/AboutTableViewsiPhone/AboutTableViewsiPhone.html#//apple_ref/doc/uid/TP40007451" target="_self">Table View Programming Guide for iOS</a></em>. </p></section><section><a name="//apple_ref/doc/uid/TP40007457-CH101-SW45" title="Handling Events"></a><h2 class="jump">Handling Events</h2><p>View controllers are themselves descendants of the <code><a href="../../../documentation/UIKit/Reference/UIResponder_Class/Reference/Reference.html#//apple_ref/occ/cl/UIResponder" target="_self">UIResponder</a></code> class and are therefore capable of handling all sorts of events. Normally, when a view does not respond to a given event, it passes that event to its superview. However, if the view is being managed by a view controller, it passes the event to the view controller object first. This gives the view controller the opportunity to absorb any events that are not handled by its views. If the view controller does not handle the event, then that event moves on to the view’s superview as usual. </p><p><span class="content_text">Figure 2-12</span> demonstrates the flow of events within a view hierarchy. Suppose you have a custom view that is embedded inside a screen-sized generic view object, which is in turn managed by your view controller. Touch events arriving in your custom view’s frame are delivered to that view for processing. If your view does not handle an event, it is passed along to the parent view. Because the generic view does not handle events, it passes those events along to its view controller first. If the view controller does not handle the event, the event is further passed along to the superview of the generic <code>UIView</code> object, which in this case would be the window object.</p><figure><a name="//apple_ref/doc/uid/TP40007457-CH101-SW21" title="Figure 2-12Responder chain for view controllers"></a><figcaption><strong>Figure 2-12&nbsp;&nbsp;</strong>Responder chain for view controllers</figcaption><img src="../Art/event_passing.jpg" alt="" width="295" height="395"></figure><div class="notebox"><aside><a name="//apple_ref/doc/uid/TP40007457-CH101-SW46" title="Note"></a><p><strong>Note:</strong>&nbsp;The message-passing relationship between a view controller and its view is managed privately by the view controller and cannot be programmatically modified by your application. </p><p></p></aside></div><p>Although you might not want to handle touch events specifically in your view controller, you could use it to handle motion-based events. You might also use it to coordinate the setting and changing of the first responder. For more information about how events are distributed and handled in iOS applications, see <em><a href="../../../documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Introduction/Introduction.html#//apple_ref/doc/uid/TP40009541" target="_self">Event Handling Guide for iOS</a></em>. </p></section><section><a name="//apple_ref/doc/uid/TP40007457-CH101-SW44" title="Accessing Related View Controller Objects"></a><h2 class="jump">Accessing Related View Controller Objects</h2><p></p><p>Although a view controller’s main responsibility is to provide and manage its view hierarchy, view controllers often work in concert with other view controllers to present more sophisticated interfaces. For example, a navigation controller manages the navigation bar view, which provides a back button and information specific to the current view controller. For the specific content, the navigation controller relies on your custom view controllers to provide that content. Tab bar controllers similarly expect your custom view controllers to provide information related to tabs. </p><p>A custom view controller is responsible for providing any specific objects needed by higher-level view controllers. <span class="content_text">Table 2-3</span> lists the types of objects your view controller should be prepared to provide and the situations in which you need to provide it. If you do not specify a custom object for any of these properties, the view controller provides an appropriate default item for you. </p><a name="//apple_ref/doc/uid/TP40007457-CH101-SW27" title="Table 2-3Supporting objects managed by your custom view controllers"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 2-3&nbsp;&nbsp;</strong>Supporting objects managed by your custom view controllers</caption><tr><th scope="col" class="TableHeading_TableRow_TableCell"><p>Object</p></th><th scope="col" class="TableHeading_TableRow_TableCell"><p>Property</p></th><th scope="col" class="TableHeading_TableRow_TableCell"><p>Description</p></th></tr><tr><td  scope="row"><p>Navigation toolbar items</p></td><td ><p><code><a href="../../../documentation/UIKit/Reference/UIViewController_Class/Reference/Reference.html#//apple_ref/occ/instp/UIViewController/toolbarItems" target="_self">toolbarItems</a></code></p></td><td ><p>Used in conjunction with a navigation controller that provides a custom toolbar. You can use this property to specify any items you want displayed in that toolbar. As the user transitions from one screen to the next, the toolbar items associated with the new view controller are animated into position.</p><p>The default behavior is to provide no custom toolbar items.</p><p>Available in iOS 3.0 and later. For information about configuring a navigation toolbar, see <span class="content_text"><a href="../NavigationControllers/NavigationControllers.html#//apple_ref/doc/uid/TP40007457-CH103-SW4">“Displaying a Navigation Toolbar.”</a></span> </p></td></tr><tr><td  scope="row"><p>Navigation bar content</p></td><td ><p><code><a href="../../../documentation/UIKit/Reference/UIViewController_Class/Reference/Reference.html#//apple_ref/occ/instp/UIViewController/navigationItem" target="_self">navigationItem</a></code></p></td><td ><p>Used in conjunction with a navigation controller. The navigation item object provides the objects to be displayed in the navigation bar when your view controller is displayed. You can use this to provide a custom title or additional controls for your view.</p><p>The default navigation item uses the title of your view controller as the title of the navigation bar and does not provide any custom buttons. The navigation controller adds the back button automatically.</p><p>For information about specifying the contents of the navigation bar, see <span class="content_text"><a href="../NavigationControllers/NavigationControllers.html#//apple_ref/doc/uid/TP40007457-CH103-SW3">“Customizing the Navigation Bar Appearance.”</a></span> </p></td></tr><tr><td  scope="row"><p>Tab bar item</p></td><td ><p><code><a href="../../../documentation/UIKit/Reference/UIViewController_Class/Reference/Reference.html#//apple_ref/occ/instp/UIViewController/tabBarItem" target="_self">tabBarItem</a></code></p></td><td ><p>Used in conjunction with a tab bar controller. The tab bar item provides the image and text to display in the tab associated with your view controller. </p><p>The default tab bar item contains the title of your view controller and no image.</p><p>For information about specifying the tab contents for your view controller, see <span class="content_text"><a href="../TabBarControllers/TabBarControllers.html#//apple_ref/doc/uid/TP40007457-CH102-SW2">“Creating a Tab Bar Interface.”</a></span> </p></td></tr></table></div><p>For more information about these properties, see <em><a href="../../../documentation/UIKit/Reference/UIViewController_Class/Reference/Reference.html#//apple_ref/doc/uid/TP40006926" target="_self">UIViewController Class Reference</a></em>. </p></section>
        <div id="pageNavigationLinks_bottom" class="pageNavigationLinks">
            <a class='nextLink' rel='next' href='../NavigationControllers/NavigationControllers.html'>Next</a><a class='previousLink' rel='prev' href='../AboutViewControllers/AboutViewControllers.html'>Previous</a>
        </div><br/>
        <div class="copyright"><br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> &#x00a9; 2010 Apple Inc. All Rights Reserved. &#40;Last updated: 2010-11-12&#041;</p></div></div>

        <div id="feedbackForm" class="hideOnPrint" style="margin-left: auto; margin-right: auto; width: 38em; margin-bottom: 15px; margin-top: 15px; font-weight: bold; color: #333333; background: #d9d9d9; padding: 5px 10px 5px 10px; height: 15px; text-align: center; -webkit-border-radius: 12px; -moz-border-radius: 12px; vertical-align: middle;">
    Did this document help you?
    <span class="tooltip" data-abstract="<b>Yes:</b> Tell us what works for you.">
       <a href="http://developer.apple.com/feedback/?v=1&url=%2Flibrary%2Fios%2Ffeaturedarticles%2FViewControllerPGforiPhoneOS%2FBasicViewControllers%2FBasicViewControllers.html%3Fdocset%3Dcom.apple.adc.documentation.AppleiOS4_2.iOSLibrary-37.11%26id%3DTP40007457-5.0&media=xcode" class='urlLink'>Yes</a>
    </span>
    <span class="tooltip" data-abstract="<b>It's good, but:</b> Report typos, inaccuracies, and so forth.">
        <a href="http://developer.apple.com/feedback/?v=2&url=%2Flibrary%2Fios%2Ffeaturedarticles%2FViewControllerPGforiPhoneOS%2FBasicViewControllers%2FBasicViewControllers.html%3Fdocset%3Dcom.apple.adc.documentation.AppleiOS4_2.iOSLibrary-37.11%26id%3DTP40007457-5.0&media=xcode" class='urlLink'>It's good, but...</a>
    </span>
    <span class="tooltip" data-abstract="<b>Not helpful:</b> Tell us what would have helped.">
        <a href="http://developer.apple.com/feedback/?v=3&url=%2Flibrary%2Fios%2Ffeaturedarticles%2FViewControllerPGforiPhoneOS%2FBasicViewControllers%2FBasicViewControllers.html%3Fdocset%3Dcom.apple.adc.documentation.AppleiOS4_2.iOSLibrary-37.11%26id%3DTP40007457-5.0&media=xcode" class='urlLink'>Not helpful...</a>
    </span>
</div>
        
        <!-- /CONTENTS -->
    </article>
</body>
<script charset="utf-8" src="../../../Resources/541/JavaScript/lib/prototype.js"></script>
<!-- Media player includes -->
<script charset="utf-8" src="../../../Resources/541/JavaScript/lib/scriptaculous.js"></script>
<script charset="utf-8" src="../../../Resources/541/JavaScript/lib/event_mixins.js"></script>
<script charset="utf-8" src="../../../Resources/541/JavaScript/lib/browserdetect.js"></script>
<script charset="utf-8" src="../../../Resources/541/JavaScript/lib/ac_media.js"></script>
<!-- /Media player includes -->
<script charset="utf-8" src="../../../Resources/541/JavaScript/devpubs.js"></script>
<script charset="utf-8" src="../../../Resources/541/JavaScript/book.js"></script>
</html>